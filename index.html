{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "# Scaling ML using Cloud ML Engine\n",
    "\n",
    "- to run the notebook underlying this presentation, go to [github.com/tarrade/proj_DL_models_and_pipelines_with_GCP](https://github.com/tarrade/proj_DL_models_and_pipelines_with_GCP)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## Contents\n",
    "\n",
    "1. Data Science Workflow\n",
    "2. Where to develop?\n",
    "3. Hands-ON Tutorial: Running MNIST on ML-Engine\n",
    "   1. Setup\n",
    "   2. Training Possibilities\n",
    "   3. Evaluation \n",
    "   4. Deployment\n",
    "4. Recap\n",
    "5. Appendix\n",
    "   1. Jupyter Slides"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "# 1. Data Science Workflow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "- Goal is to standardise the development of models\n",
    "     - Checklist of necessary technical steps"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "> Vision: Achieve an first end-to-end model in production within a *productincrement* of 10 weeks"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "> Scale out: Scale without having to rewrite your model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "code_folding": [
     0
    ],
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "%%javascript // some javascript to render markdown tables properly\n",
    "\n",
    "// from https://github.com/jupyter/notebook/issues/3024#issuecomment-435630413\n",
    "var marked = require('components/marked/lib/marked');\n",
    "\n",
    "if (marked.Renderer.name !== 'NonExtensibleTableRenderer') {\n",
    "    function tablecell(content, flags) {\n",
    "        var type = flags.header ? 'th' : 'td';\n",
    "        var style = flags.align == null ? '' : ' style=\"text-align: ' + flags.align + '\"';\n",
    "        var start_tag = '<' + type + style + '>';\n",
    "        var end_tag = '</' + type + '>\\n';\n",
    "        return start_tag + content + end_tag;\n",
    "    }\n",
    "\n",
    "    var DefaultRenderer = marked.Renderer;\n",
    "    function NonExtensibleTableRenderer(options) {\n",
    "        DefaultRenderer.call(this, options);\n",
    "        Object.defineProperty(this, 'tablecell', {\n",
    "            get: function () { return tablecell; },\n",
    "            set: function () { } // No-op, sorry for this hack but we must prevent it from being redefined\n",
    "        });\n",
    "    }\n",
    "    NonExtensibleTableRenderer.prototype = Object.create(DefaultRenderer.prototype);\n",
    "    NonExtensibleTableRenderer.prototype.constructor = NonExtensibleTableRenderer;\n",
    "\n",
    "    marked.setOptions({\n",
    "        renderer: new NonExtensibleTableRenderer()\n",
    "    });\n",
    "    // Look away... it has to be done as newer versions of the notebook build a custom\n",
    "    // renderer rather than extending the default.\n",
    "    marked.Renderer = NonExtensibleTableRenderer;\n",
    "}\n",
    "\n",
    "var Jupyter = require('base/js/namespace');\n",
    "Jupyter.notebook.get_cells()\n",
    "   .filter(cell => cell.cell_type === 'markdown' && cell.rendered)\n",
    "   .forEach(mdcell => {\n",
    "       mdcell.unrender();\n",
    "       mdcell.render();\n",
    "   });"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "\n",
    "### Data Science Process - Proposal\n",
    "\n",
    "|   Step 1: Preparation       |      Step 2: Data exploration and model building                   |    Step 3: Model deployment                    \n",
    "|   :-----      |      :----                 |   :----\n",
    "| 1.1  Project setup          | 2.1  One click to start the Data Scientist Exploration Environment | 3.1  Model serving                             \n",
    "| 1.2  Quick data exploration | 2.2  Setup for Data exploration and Machine Learning               | 3.2  Model deployment (load balancing ...)     \n",
    "| 1.3  Data visualization     | 2.3  Deep dive in data exploration                                 | 3.3  Model versioning                           \n",
    "|        -                    | 2.4  Data visualization and profiling                              | 3.4  Model monitoring                          \n",
    "|        -                    | 2.5  Feature engineering                                           |                        -                       \n",
    "|        -                    | 2.6  Model building                                                |                        -                       \n",
    "|        -                    | 2.7  Model training                                                |                        -                       \n",
    "|        -                    | 2.8  Model testing                                                 |                        -                       \n",
    "|        -                    | 2.9  Hyparameters tuning                                           |                        -                       \n",
    "|        -                    | 2.10 Model visualisation                                           |                        -                       \n",
    "> steps 1 and 2 can be done *only* locally"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "We will look today at\n",
    "    - 2.7 How to train a model?\n",
    "    - 2.8 How to evaluate a model?\n",
    "    - 3.1 How to make predictions?\n",
    "    - 3.2 How to deploy a model?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Should help to answer:\n",
    "- Where do we need to improve?\n",
    "- Where to go next?\n",
    "\n",
    "> Process description will be refined."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### [Scaling Michelangelo](https://eng.uber.com/scaling-michelangelo/) - Data Science Process at Uber\n",
    "![Data Science Process at Uber](Images/uber_michelangelo_at_scale.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "# 2. Where to develop?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "center",
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "|SDK on local Machine | Google Console |\n",
    "|---------------------|----------------|\n",
    "| your machine | Tiny Compute Engine with 5 GB storage |\n",
    "| Your IDE | Code Editor|\n",
    "| Jupyter Notebook | Datalab |\n",
    "| `gcloud ml-engine local` | `gcloud ml-engine`\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Locally using\n",
    "- Google SDK on your laptop (CLI)\n",
    "- your IDE (e.g. PyCharme)\n",
    "- Juypter Notebook\n",
    "- `gcloud ml-engine local` "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Simple Cloud setup using\n",
    "- [Google Console](https://console.cloud.google.com/) Compute Engine with 5 GB storage\n",
    "- Cloud Editor\n",
    "- datalab\n",
    "- `gcloud ml-engine` (`local`)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## Proposal"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "- when to migrate to GCP:\n",
    "   - distribute learning on several machines\n",
    "   - serve model 24/7\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "> develop locally\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "# 3. Hands-ON Tutorial: Running MNIST on ML-Engine"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "- deep dive into step 2 and 3 of proposed Data Science process\n",
    "- data exploration is omitted as a curated dataset is used"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Adapted from [Notebook](https://github.com/GoogleCloudPlatform/training-data-analyst/blob/master/courses/machine_learning/cloudmle/cloudmle.ipynb) of Google Coursera Course [Serverless Machine Learning with Tensorflow on Google Cloud Platform](https://www.coursera.org/learn/serverless-machine-learning-gcp/). The current code respository is [github/tarrade/tarrade/proj_DL_models_and_pipelines_with_GCP/](https://github.com/tarrade/proj_DL_models_and_pipelines_with_GCP/)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "- In order to import from `src` functionality later in this notebook, it is necessary to change to the root directory of the notebooks directory"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "center",
    "code_folding": [
     0,
     5
    ],
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# check working directory\n",
    "import os\n",
    "WORKINGDIR = os.getcwd()\n",
    "print(\"Current Working direcotory:\\t{}\".format(WORKINGDIR))\n",
    "folders = WORKINGDIR.split('/')\n",
    "if folders.pop() == 'notebook':  # or a list: in ['notebook', 'src', etc.]\n",
    "  WORKINGDIR = '/'.join(folders)\n",
    "  print(\"Changed to New working directory:\\t{}\".format(WORKINGDIR))\n",
    "  os.chdir(WORKINGDIR) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## MNIST use-case"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "#### Create an test-image in numpy format saved as json (copy from test set)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "code_folding": [
     0
    ],
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "# Create a file with 4 test images\n",
    "N=4\n",
    "import numpy as np\n",
    "import json\n",
    "from src.pkg_mnist_fnn.utils import load_data\n",
    "from src.pkg_mnist_fnn.model import parse_images\n",
    "(_,_), (x_test, y_test) = load_data(rel_path='data')\n",
    "test_indices = np.random.randint(low=0, high=len(y_test), size=N)\n",
    "x_test, y_test = x_test[test_indices], y_test[test_indices]\n",
    "x_test = parse_images(x_test).tolist()\n",
    "\n",
    "eol = \"\\r\\n\"\n",
    "n_lines = len(y_test)\n",
    "with open(\"data/test.json\", \"w\") as f:\n",
    "    for image, label in zip(x_test, y_test):\n",
    "        _dict = {\"x\": image} #, \"y\": int(label)}\n",
    "        f.write(json.dumps(_dict) + eol)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "center",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "- recognise hand-written digits (e.g. on a postal card) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [
    {
     "data": {
      "image/png": "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T39azDbYYIO2xx988MHiOZ2+55s/f34x62TTTTctZm9961uL2eGHH17MOm2Lsvvuuxez5cuXtz3+xS9+sXjO97///WJ26623FrNObG8CAADAwFloAgAAUJWFJgAAAFVZaAIAAFCVhSYAAABVWWgCAABQle1NGmznnXcuZrfddlvVa/W6pciSJUuKWa8zdro9fadZjj766GJ2zjnn9DRLbW7TPn5MmTKlmN15553FbLPNNitmV111VdvjTdrCpJNO2yu85z3vKWYLFy4sZh/84AfbHr/mmmu6H6wC3WyWs88+u5gdc8wxA5vjsssuK2Yf//jHi9nvfve7foyzVtLNieGQQw4pZt/61rdG/Xhbb711MVu8ePGoH28YJk2aVMxK26FFlLdM2WGHHYrndNoupdP3z1dccUUxs70JAAAAA2ehCQAAQFUWmgAAAFRloQkAAEBVFpoAAABUZaEJAABAVeX76raklC6KiP0iYlnO+TWtYy+OiMsiYpuIWBAR78g5/6F/Y05cb37zm4vZ5Zdf3tNjXnrppW2P33XXXcVzli1bVsy+973vFbNnn322mD355JPF7KijjipmnbZ6eOqpp4rZtddeW8wmIt0cu05bmNx4443FbOrUqcXsy1/+cjE77rjjuhtsiI4//vhi9t73vreYPfTQQ8XskksuKWY//vGPu5prPNHNseu0TdAg7b///sXsq1/9ajH705/+VMyefvrpMc1E73RzeA477LCezrv11lvbHn/88cfHMk4jPPfcc8XsN7/5TTE75ZRT+jFOX3TziuasiNjnecc+FRFzc87bRcTc1p+BwZoVuglNNCt0E5poVugmDMyIC82c840R8fx/NjggIi5ufXxxRIyP3cZhAtFNaCbdhGbSTRisXn9Gc0rO+ZGIiNbvm9YbCRgD3YRm0k1oJt2EPhnxZzTHKqU0MyJm9vs6wOjoJjSTbkIz6SaMTq+vaC5NKU2NiGj9XryTTM75/JzzLjnnXXq8FtA93YRm0k1oJt2EPul1oXllRLy79fG7I+K7dcYBxkg3oZl0E5pJN6FPUs658yek9M2I2DMi/jUilkbESRHxnYj4VkRsFRGLIuLfcs4j3mc4pdT5YhPUK1/5ymL2k5/8pJhtumn5xwQWLlxYzHbccce2x5cvX148px/23nvvYvbtb3+7mP3zP/9zMTvxxBOL2RlnnNHdYEOUc061Hks3u/ORj3ykmB155JHFbKeddipmnW6rvsceexSzX/3qV8VskPbcc89idtFFFxWzbbbZppj94Ac/KGbTp0/vZqyh0s1mKW3TFRHx7//+7wOcpCyl8l+Zhx9+uJgdfvjhxazTtkorV67sbrAJRjfHj0022aSYddoC69FHHy1m2223Xdvjf/nLX7ofjL7oppsj/oxmznlGIdpr1BMB1egmNJNuQjPpJgxWr2+dBQAAgLYsNAEAAKjKQhMAAICqLDQBAACoykITAACAqka86yzd6bQVwpe//OVittlmmxWzJ554oph12p5gkNuYTJs2rZhdeeWVxWyDDTYoZk8++WQxmzNnTneDsVbZeuuti9npp59ezDbaaKNi9thjjxWz/fffv5g1ZQuTTs4666xi1um5nDdvXjG7+OKLxzQTrK7TNjul7Q4iInbeeed+jDNqL33pS4vZ3Llzi9kRRxxRzGbPnj2WkaDv9t1332K2/vrrF7MVK1YUM9uYjG9e0QQAAKAqC00AAACqstAEAACgKgtNAAAAqrLQBAAAoCoLTQAAAKqyvckodLo185lnnlnMXv/61xezhx56qJgde+yxxWzRokXFrLZ11in/e8RBBx1UzDo9X08//XQxe+1rX1vMBvl10yyTJ08uZmeccUYx23DDDXu63owZM4rZz3/+854esymWLl3a03nHHHNMMbv55pt7HQfWcMMNNxSzTv3rtGXYhz70oWK27bbbtj3eaSujfthvv/2Kme1NaLpOW4axdvKKJgAAAFVZaAIAAFCVhSYAAABVWWgCAABQlYUmAAAAVaWc8+AultLgLtYHX/rSl4pZp7vZdXLaaacVs5NPPrmnx6zt0EMPLWZz5szp6TFPOeWUYnbqqaf29JjjQc45DXuGdprSzR133LGYnXfeecVs1113rT7Lgw8+WMw63bV17ty5xWzhwoWjnuMb3/jGqM+J6Hwn3sMOO6yYzZs3r5jNnDmzmPV6J9um0E3amTZtWjHr9P+qTneP7dVRRx1VzDr993G8083x4yUveUkx+93vflfMHn/88WK20047tT2+ZMmS7gejL7rpplc0AQAAqMpCEwAAgKosNAEAAKjKQhMAAICqLDQBAACoykITAACAqkbc3iSldFFE7BcRy3LOr2kdOzki3h8Rv2992gk556tHvNg4vxX0FVdcUcze9ra3FbMbbrihmB1wwAHF7JlnnulusAqmTp1azDrNv/322xez22+/vZi94Q1vKGZ//etfi9l4V/M27ROxm1dddVUxmz59ejF77LHHitm9997b0yyd/o4OcluoZcuWFbPrr7++mHXawmTBggXFrNN/y+bPn1/MxjvdZLQmT55czGbNmlXMDj744J6ud8sttxSz3XffvafHHA90c/z4p3/6p2L2s5/9rJh12trsne98Z9vj3/zmN7sfjL6otb3JrIjYp83xL+Scp7V+jVhIoLpZoZvQRLNCN6GJZoVuwsCMuNDMOd8YEeWdVIGh0E1oJt2EZtJNGKyx/Izmh1NKd6WULkopvajaRMBY6SY0k25CM+km9EGvC82vRcTLI2JaRDwSEZ8vfWJKaWZK6faUUvkH9oBadBOaSTehmXQT+qSnhWbOeWnOeUXOeWVEXBARu3b43PNzzrvknHfpdUigO7oJzaSb0Ey6Cf3T00IzpbT6LUoPioiJeytCGEd0E5pJN6GZdBP6Z9JIn5BS+mZE7BkR/5pSWhwRJ0XEnimlaRGRI2JBRPxnH2dsjHPPPbeYPfjgg8Xs1FNPLWaD3MKkk8suu6yYddrCZOHChcVsxowZxWwib2EyKBOxm3fffXcxu+OOO4rZBRdcUMwefvjhnmZ51ate1dN5e++9dzHbYost2h7fb7/9iue8/OUvL2b/8R//Ucw6bcHyhS98oZhN5C1MBmUidpM1PfXUU8Ws0/cLvW5vwtjpZn89/fTTxeyLX/xiMbvooouK2Ve+8pW2x3/7298Wz7n11luL2cqVK4sZ9Y240Mw5t1stXNiHWYBR0E1oJt2EZtJNGKyx3HUWAAAA1mChCQAAQFUWmgAAAFRloQkAAEBVFpoAAABUlTrdAr/6xVIa3MXWYhtuuGHb4xdffHHxnLe//e3F7Nlnny1mH/jAB4rZN77xjWK2tso5p2HP0I5uNteCBQuK2ZZbblnMPv3pTxez008/vZh16vtEppvUtNdeexWz6667rqfHvOWWW4rZ7rvv3tNjjge6OTGUtveKiJg9e3Yx22OPPUZ9rWuuuaaYnXXWWcXsRz/60aivtTbrppte0QQAAKAqC00AAACqstAEAACgKgtNAAAAqrLQBAAAoCoLTQAAAKqaNOwBqO/CCy9se/zggw8untNpS4Ojjz66mNnCBLq36aabtj0+d+7c4jlbbbVVMXv00UeLmS1MaLpOf7ePPPLInh7z6quvLma33nprT49ZssEGGxSzQw89tOq1YLxbvHhxMev0/enxxx/f9vhHPvKR4jn77LNPMbvqqquKme1N6vOKJgAAAFVZaAIAAFCVhSYAAABVWWgCAABQlYUmAAAAVVloAgAAUJXtTcap3XbbrZgdeOCBo368M844o5idd955o348YE2HH3542+M77LBD8ZylS5eO+vEibGFC8/3whz8sZttuu21Pj3niiScWs2uuuaaYnXTSSW2Pv+pVryqeU9quKKL37VlgbfSHP/yhmB177LFtj7///e8vnvOCF7xgzDNRh1c0AQAAqMpCEwAAgKosNAEAAKjKQhMAAICqLDQBAACoykITAACAqkbc3iSltGVEXBIRm0XEyog4P+f8XymlF0fEZRGxTUQsiIh35JzL9ydm1CZPnlzMLrjggmJWuq3zDTfcUDznzDPP7H4wGkE3m+mzn/1sMfvkJz856sd74xvfWMzuv//+UT8e/aebfzdt2rRitsUWW1S/3jrrlP/9fN999y1me+65Z9vjG264YfGclFIxyzkXs046nfe1r32tp8fk73SzmdZdd91idvLJJ7c9vvHGGxfPeeyxx4rZvHnzup6LsevmFc3nIuITOedXR8T/iYgPpZR2iIhPRcTcnPN2ETG39WdgcHQTmkk3oZl0EwZoxIVmzvmRnPOdrY+fjIh7ImLziDggIi5ufdrFEXFgv4YE1qSb0Ey6Cc2kmzBYI751dnUppW0i4nURcUtETMk5PxKxqrgppU0L58yMiJljGxPoRDehmXQTmkk3of+6XmimlDaKiMsj4qM55yc6/WzC6nLO50fE+a3H6O2HFoAi3YRm0k1oJt2EwejqrrMppfViVSHn5Jz/p3V4aUppaiufGhHL+jMiUKKb0Ey6Cc2kmzA4Iy4006p/5rkwIu7JOZ+9WnRlRLy79fG7I+K79ccDSnQTmkk3oZl0EwYrjXQL7pTSGyLipoj4Zay6FXRExAmx6j3t34qIrSJiUUT8W8758REey9sMnmfKlCnF7JJLLilme++9dzH74x//2Pb4brvtVjzngQceKGbUk3Pu7v05XdDN/lpvvfWK2dlnn13M3vWudxWzJ554ou3xGTNmFM+5+eabixn16GZ/vO997ytm55133gAnqa/TViorV64sZp1ceumlxezwww/v6THHO92c+E477bRidsIJJ7Q9vnz58uI5nb7fvffee7sfjI666eaIP6OZc745IkoPtNdohwLq0E1oJt2EZtJNGKyufkYTAAAAumWhCQAAQFUWmgAAAFRloQkAAEBVFpoAAABUNeJdZ+mvY489tpi96U1vKmaPPfZYMXvFK17R9vif/vSn7geDtdzWW29dzA477LBiVtrCJCLi6KOPbnvcFiZMVFdffXUx+/73v1/Mpk+f3o9xqhppe7iSRYsWFbNTTjml13FgVF7zmtcUs5122qmYzZkzp5itu+66xezUU08tZscdd1wxe+qpp9oeP/jgg4vn2MKkObyiCQAAQFUWmgAAAFRloQkAAEBVFpoAAABUZaEJAABAVRaaAAAAVJV6vT13TxdLaXAXa5BOWyHMnj27mK1YsaKYdboF+umnn97dYAxczjkNe4Z21tZudrLeeusVs/e85z3F7Pe//30xu+KKK8Y0E/2jm4PXaSuELbfcspgdeuihxezEE08sZvfff38xmzZtWjEruemmm4rZvHnzitm5555bzO67775RzzHR6WZ/fOpTnypmJ510UjF79atfXcyOPPLIYtapm3/+85+L2SGHHNL2+HXXXVc8h8Hoppte0QQAAKAqC00AAACqstAEAACgKgtNAAAAqrLQBAAAoCp3na3kiCOOKGaf+9znitkmm2xSzD7zmc8Us+OPP76ruWgWd8+DZtJNaCbd7I8dd9yxmP385z8vZuusU36NatKkScVs+fLlxax0Z9mIiLlz5xYzhstdZwEAABg4C00AAACqstAEAACgKgtNAAAAqrLQBAAAoCoLTQAAAKoacXuTlNKWEXFJRGwWESsj4vyc83+llE6OiPdHxO9bn3pCzvnqER5rXN8KeuONNy5m9913XzGbMmVKMbv++uuL2fTp04vZihUrihnNVfM27boJ9egmNJNuDt5pp51WzE444YRidskllxSzM888s5h1+h6a5uqmm+UNb/7uuYj4RM75zpTSxhFxR0rpb6ujL+SczxrLkEDPdBOaSTehmXQTBmjEhWbO+ZGIeKT18ZMppXsiYvN+DwZ0ppvQTLoJzaSbMFij+hnNlNI2EfG6iLildejDKaW7UkoXpZReVHk2oEu6Cc2km9BMugn91/VCM6W0UURcHhEfzTk/ERFfi4iXR8S0WPWvQ58vnDczpXR7Sun2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\n",
      "text/plain": [
       "<Figure size 1440x288 with 4 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "from src.utils.mnist_utils import plot_mnist_testdata \n",
    "plot_mnist_testdata()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "<img src=\"Images/gcp_training_options-Modelling.jpg\" />"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "![](https://ml4a.github.io/images/figures/mnist-input.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Why MNIST?\n",
    "- images need pre-processing\n",
    "- black and white images are numeric vectors"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## 3.A Setup\n",
    "\n",
    "1. ML Engine Runtimes\n",
    "2. Repository Structure\n",
    "3. Configuration Variables\n",
    "    -  Environment variables to set\n",
    "    - How to add them to your runtime\n",
    "4. Setup `gcloud` runtime"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Create conda environement\n",
    "  - `conda env create -f environment.yml -n env_gcp_dl`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### 1 ML Engine Runtimes\n",
    "Default ML-Engine Runtimes depend on the Tensorflow Version\n",
    "- [list of runtimes](https://cloud.google.com/ml-engine/docs/tensorflow/runtime-version-list)\n",
    "- Current Version: `1.12`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "#!conda install tensorflow=1.12"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'1.12.0'"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import tensorflow as tf\n",
    "tf.__version__"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "source activate gcp_dl\n",
    "TF_VERSION=$(python3 -c 'import tensorflow as tf; print(tf.__version__)')\n",
    "if $TF_VERSION != \"1.12.0\"\n",
    "then\n",
    "    pip install tensorflow==1.12\n",
    "fi\n",
    "    echo \"Found Tensorflow: $TF_VERSION\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "- current version of gcp datalab\n",
    "- will be different on Windows machines\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### 2. Repository structure"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "ls | grep \"/\\|yaml\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Key Directories containing information\n",
    "```\n",
    ".\n",
    "+-- data\n",
    "+-- src\n",
    "|  +-- models\n",
    "|  +-- packages\n",
    "config.yaml\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "center",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "In the next step the contents of [`config.yaml`](config.yaml) will be important"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "!cat config.yaml"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### 3. GCP Environment Variables"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "- `PROJECT_ID`: unique ID that identifies your project, e.g. **ml-productive-pipeline-12345**\n",
    "- `BUCKET`: BLOB-store ID. Each project has per default an bucket named by the `PROJECT_ID`\n",
    "- `REGION`: Which data center to use"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Additional Environment Variables needed for ML-Engine\n",
    "- `PKG_NAME`: Package Name which will contain your model\n",
    "- `TF_VERSION`: Tensorflow Version"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "# # #Create config manually and save as yaml:\n",
    "# config = {}\n",
    "# config['project-id'] = 'PROJECT'  # # REPLACE WITH YOUR PROJECT ID\n",
    "# config['region'] = 'europe-west1' # Choose an available region for Cloud MLE from https://cloud.google.com/ml-engine/docs/regions.\n",
    "# config['bucket'] = 'Bucket-name'  # REPLACE WITH YOUR BUCKET NAME. Use a regional bucket in the region you selected.\n",
    "# \n",
    "# with open(\"../config_from_python.yaml\", 'wb', encoding= 'utf8') as f:\n",
    "#     yaml.dump(f)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "import yaml\n",
    "from pprint import pprint\n",
    "with open(\"config.yaml\", \"r\", encoding = \"utf8\") as f:\n",
    "    config = yaml.load(f)\n",
    "pprint(config)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "notes"
    }
   },
   "source": [
    "#### Environment variables for project and bucket\n",
    "\n",
    "Note that:\n",
    "1. Your project id is the *unique* string that identifies your project (not the project name). You can find this from the GCP Console dashboard's Home page. My dashboard reads:  \n",
    "     \n",
    "     - Project ID: ml-productive-pipeline-12345\n",
    "     \n",
    "2. Cloud training often involves saving and restoring model files. If you don't have a bucket already, I suggest that you create one from the GCP console (because it will dynamically check whether the bucket name you want is available). A common pattern is to prefix the bucket name by the project id, so that it is unique. Also, for cost reasons, you might want to use a single region bucket.\n",
    "\n",
    "\n",
    "Add all detail in to [config.yaml](../config.yaml) file in main directory. Missing in public repository.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "#### Adding Environment Variables to your runtime\n",
    "- add variables **persistently**  to the runtime of your kernel from jupyter (or datalab)\n",
    "- use `os.environ` dictionary"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "import os\n",
    "PROJECT = config['project-id'] \n",
    "REGION = config['region'] # Choose an available region for Cloud MLE from https://cloud.google.com/ml-engine/docs/regions.\n",
    "BUCKET = config['bucket'] # REPLACE WITH YOUR BUCKET NAME. Use a regional bucket in the region you selected.\n",
    "PKG_NAME = config['pkg-name']\n",
    "\n",
    "os.environ['PROJECT'] = PROJECT\n",
    "os.environ['BUCKET'] = BUCKET\n",
    "os.environ['REGION'] = REGION\n",
    "os.environ['TFVERSION'] = str(config['tf-version'])  # Tensorflow version 1.4 before\n",
    "os.environ['PKG_NAME'] = config['pkg-name']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Now, you can access the environement variable in the terminal where your jupyter, datalab or iphyton."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "!echo \"Using Tensorflow Version: $TFVERSION\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### 4. Setup gcloud runtime\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "gcloud config set project $PROJECT\n",
    "gcloud config set compute/region $REGION"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### Access Control \n",
    "\n",
    "- not necessary if you use \n",
    "  - datalab\n",
    "  - local sdk\n",
    "\n",
    "- Service Accounts ([Creating and Managing Service Accounts](https://cloud.google.com/iam/docs/creating-managing-service-accounts))\n",
    "  - need be assigned read/write permission to `BUCKET`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "source activate gcp_dl\n",
    "PROJECT_ID=$PROJECT\n",
    "AUTH_TOKEN=$(gcloud auth print-access-token)\n",
    "#echo \"Auth-Token: $AUTH_TOKEN\n",
    "SVC_ACCOUNT=$(curl -X GET -H \"Content-Type: application/json\" \\\n",
    "    -H \"Authorization: Bearer $AUTH_TOKEN\" \\\n",
    "    https://ml.googleapis.com/v1/projects/${PROJECT_ID}:getConfig \\\n",
    "    | python -c \"import json; import sys; response = json.load(sys.stdin); \\\n",
    "    print(response['serviceAccount'])\")\n",
    "echo \"Current Service Account of VM: $SVC_ACCOUNT\"\n",
    "echo \"Authorizing the Cloud ML Service account $SVC_ACCOUNT to access files in Bucket: $BUCKET\"\n",
    "gsutil -m defacl ch -u $SVC_ACCOUNT:R gs://$BUCKET\n",
    "gsutil -m acl ch -u $SVC_ACCOUNT:R -r gs://$BUCKET # error message (if bucket is empty) can be ignored\n",
    "gsutil -m acl ch -u $SVC_ACCOUNT:W gs://$BUCKET"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "## Beyond Scripting: Packaging up the code"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Take your code and put into a standard Python package structure, see  [pkg_mnist_fnn/model.py](../src/pkg_mnist_fnn/model.py)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Key-Idea: \n",
    " - define entry point which can be called\n",
    " - write all tasks as a function (callable)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    " \n",
    "Why a package?\n",
    " - can be called from other scripts `import model`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### `model.py`\n",
    "\n",
    "load most recent version, if needed:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%load src/pkg_mnist_fnn/model.py"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "```python\n",
    "import tensorflow as tf\n",
    "import numpy as np\n",
    "\n",
    "from .utils import load_data\n",
    "##########################################################################\n",
    "#Factor into config:\n",
    "N_PIXEL = 784\n",
    "OUTDIR = 'trained'\n",
    "EPOCHS = 5\n",
    "\n",
    "IMAGE_SIZE = 28 * 28\n",
    "NUM_LABELS = 10\n",
    "BATCH_SIZE = 128\n",
    "##########################################################################\n",
    "def parse_images(x):\n",
    "    return x.reshape(len(x), -1).astype('float32')\n",
    "\n",
    "\n",
    "def parse_labels(y):\n",
    "    return y.astype('int32')\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "```python\n",
    "\n",
    "\n",
    "def numpy_input_fn(images: np.ndarray,\n",
    "                   labels: np.ndarray,\n",
    "                   mode=tf.estimator.ModeKeys.EVAL):\n",
    "    \"\"\"\n",
    "    Return depending on the `mode`-key an Interator which can be use to feed into\n",
    "    the Estimator-Model. \n",
    "\n",
    "    Alternative if a `tf.data.Dataset` named `dataset` would be created:\n",
    "    `dataset.make_one_shot_iterator().get_next()`\n",
    "    \"\"\"\n",
    "    if mode == tf.estimator.ModeKeys.TRAIN:\n",
    "        _epochs = EPOCHS\n",
    "        _shuffle = True\n",
    "        _num_threads = 2\n",
    "    else:\n",
    "        _epochs = 1\n",
    "        _shuffle = False\n",
    "        _num_threads = 1\n",
    "\n",
    "    return tf.estimator.inputs.numpy_input_fn(\n",
    "        {'x': images},\n",
    "        y=labels,\n",
    "        batch_size=BATCH_SIZE,\n",
    "        num_epochs=_epochs, # Boolean, if True shuffles the queue. \n",
    "                            # Avoid shuffle at prediction time.\n",
    "        # Boolean, if True shuffles the queue. Avoid shuffle at prediction\n",
    "        shuffle=_shuffle,\n",
    "        queue_capacity=1000, # Integer, number of threads used for reading\n",
    "        # and enqueueing. To have predicted order of reading and enqueueing, \n",
    "        # such as in prediction and evaluation mode, num_threads should be 1.\n",
    "        num_threads=_num_threads\n",
    "    )\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "\n",
    "```python\n",
    "def serving_input_fn():\n",
    "    feature_placeholders = {\n",
    "        'x': tf.placeholder(tf.float32, shape=[None, N_PIXEL])\n",
    "    }\n",
    "    features = feature_placeholders\n",
    "    return tf.estimator.export.ServingInputReceiver(\n",
    "         features=features, \n",
    "         receiver_tensors=feature_placeholders,\n",
    "         receiver_tensors_alternatives=None\n",
    "         )\n",
    "\n",
    "\n",
    "\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "```python\n",
    "def train_and_evaluate(args):\n",
    "    \"\"\"\n",
    "    Utility function for distributed training on ML-Engine\n",
    "    www.tensorflow.org/api_docs/python/tf/estimator/train_and_evaluate \n",
    "    \"\"\"\n",
    "    # Load Data in Memoery\n",
    "    (x_train, y_train), (x_test, y_test) = load_data(\n",
    "        rel_path=args['data_path'])\n",
    "  \n",
    "    x_train = parse_images(x_train)\n",
    "    x_test = parse_images(x_test)\n",
    "\n",
    "    y_train = parse_labels(y_train)\n",
    "    y_test = parse_labels(y_test)\n",
    "\n",
    "    model = tf.estimator.DNNClassifier(\n",
    "        hidden_units=[256, 128, 64],\n",
    "        feature_columns=[tf.feature_column.numeric_column(\n",
    "            'x', shape=[N_PIXEL, ])],\n",
    "        model_dir=args['output_dir'],\n",
    "        n_classes=10,\n",
    "        optimizer=tf.train.AdamOptimizer,\n",
    "        # activation_fn=,\n",
    "        dropout=0.2,\n",
    "        batch_norm=False,\n",
    "        loss_reduction='weighted_sum',\n",
    "        warm_start_from=None,\n",
    "        config = None\n",
    "    )   \n",
    "    train_spec = tf.estimator.TrainSpec(\n",
    "    # see next slide\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "```python\n",
    "def train_and_evaluate(args):\n",
    "    \"\"\"\n",
    "    Utility function for distributed training on ML-Engine\n",
    "    www.tensorflow.org/api_docs/python/tf/estimator/train_and_evaluate \n",
    "    \"\"\"\n",
    "    # see previous slide\n",
    "\n",
    "    model = tf.estimator.DNNClassifier(\n",
    "    # see previous slide\n",
    "    )   \n",
    "    train_spec = tf.estimator.TrainSpec(\n",
    "        input_fn=numpy_input_fn(\n",
    "            x_train, y_train, mode=tf.estimator.ModeKeys.TRAIN),\n",
    "        max_steps=args['train_steps'],\n",
    "        hooks = None\n",
    "    )\n",
    "    exporter = tf.estimator.LatestExporter('exporter', serving_input_fn)\n",
    "    eval_spec = tf.estimator.EvalSpec(\n",
    "        input_fn=numpy_input_fn(\n",
    "            x_test, y_test, mode=tf.estimator.ModeKeys.EVAL),\n",
    "        steps=None,\n",
    "        start_delay_secs=args['eval_delay_secs'],\n",
    "        throttle_secs=args['min_eval_frequency'],\n",
    "        exporters=exporter\n",
    "    )\n",
    "    tf.estimator.train_and_evaluate(\n",
    "        estimator=model, train_spec=train_spec, eval_spec=eval_spec)\n",
    "\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### `task.py`\n",
    "\n",
    "load most recent file using:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%load src/pkg_mnist_fnn/task.py"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "```python\n",
    "\"\"\"\n",
    "Parse arguments and call main function\n",
    "\"\"\"\n",
    "import os\n",
    "import argparse\n",
    "import shutil\n",
    "\n",
    "from .model import train_and_evaluate\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    parser = argparse.ArgumentParser()\n",
    "    parser.add_argument(\n",
    "        '--data_path',\n",
    "        help='GCS or local path to training data',\n",
    "        required=True\n",
    "    )\n",
    "    parser.add_argument(\n",
    "        '--output_dir',\n",
    "        help='GCS location to write checkpoints and export models',\n",
    "        required=True\n",
    "    )\n",
    "    parser.add_argument(\n",
    "        '--train_batch_size',\n",
    "        help='Batch size for training steps',\n",
    "        type=int,\n",
    "        default='128'\n",
    "    )\n",
    "    parser.add_argument(\n",
    "        '--train_steps',\n",
    "        help='Steps to run the training job for',\n",
    "        type=int,\n",
    "        default='200'\n",
    "    )\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "```python\n",
    "    parser.add_argument(\n",
    "        '--hidden_units',\n",
    "        help='List of hidden layer sizes to use for DNN feature columns',\n",
    "        nargs='+',\n",
    "        type=int,\n",
    "        default=[128, 64, 32]\n",
    "    )\n",
    "    parser.add_argument(\n",
    "        '--job_dir',\n",
    "        help='this model ignores this field, but it is required by gcloud',\n",
    "        default='junk'\n",
    "    )\n",
    "    # Eval arguments\n",
    "    parser.add_argument(\n",
    "        '--eval_delay_secs',\n",
    "        help='How long to wait before running first evaluation',\n",
    "        default=1,\n",
    "        type=int\n",
    "    )\n",
    "    parser.add_argument(\n",
    "        '--min_eval_frequency',\n",
    "        help='Seconds between evaluations',\n",
    "        default=10,\n",
    "        type=int\n",
    "    )\n",
    "\n",
    "    args = parser.parse_args().__dict__\n",
    "\n",
    "    OUTDIR = args['output_dir']\n",
    "    # #######################################\n",
    "    # # Train and Evaluate (use TensorBoard to visualize)\n",
    "    train_and_evaluate(args)\n",
    "\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "# 3.B Train using ML-Engine on"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "### your local machine\n",
    "![laptop-icon-24](Images/laptop-icon-24.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "1. Call your python script (module)\n",
    "2. Use `gcloud ml-engine local train`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### a cluster of machines using ML-Engine service"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "![CloudMachineLearning.png](Images/CloudMachineLearning.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "3. Use `gcloud ml-engine train`"
   ]
  },
  {
   "attachments": {
    "gcp_training_options.svg": {
     "image/svg+xml": [
      "PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSk7IiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iNTA2cHgiIGhlaWdodD0iMjc5cHgiIHZpZXdCb3g9Ii0wLjUgLTAuNSA1MDYgMjc5IiBjb250ZW50PSImbHQ7bXhmaWxlIG1vZGlmaWVkPSZxdW90OzIwMTktMDItMjVUMTU6MTI6NTAuNjEzWiZxdW90OyBob3N0PSZxdW90O3d3dy5kcmF3LmlvJnF1b3Q7IGFnZW50PSZxdW90O01vemlsbGEvNS4wIChYMTE7IFVidW50dTsgTGludXggeDg2XzY0OyBydjo2NS4wKSBHZWNrby8yMDEwMDEwMSBGaXJlZm94LzY1LjAmcXVvdDsgZXRhZz0mcXVvdDtVUGdPb1VFZUZVeC05SnNKakFTMCZxdW90OyB2ZXJzaW9uPSZxdW90OzEwLjIuNyZxdW90OyB0eXBlPSZxdW90O2RldmljZSZxdW90OyZndDsmbHQ7ZGlhZ3JhbSBpZD0mcXVvdDs4NXI5X1RzWHJrQXJfNThOajF0NCZxdW90OyBuYW1lPSZxdW90O1BhZ2UtMSZxdW90OyZndDt6YnhaMTZzNGxpMzZhL0t4eHFCdkhrV1BEUmd3eHNBYmZRL0c5UHo2SzMxN1IyUkVaZFVkNTU1YlZlZnNES2YwQ1ZsSVMwdHp6U21CLzBHSy9hRis0MDlsamxuZS9ZUEFzdU1mcFBRUGdzQXBnb0VKS2psL2xiQWM5cXVnL05iWjcwci9MSGpXVi82NzhJOXFhNTNsODk4cUx1UFlMZlhuNzRYcE9BeDV1dnl0TFA1K3gvM3YxWXF4Ky90ZFAzR1ovMHZCTTQyN2Z5MTkxOWxTL1NwbGFPeWY1VnBlbDlYdk8xUFk3d3Q5L0VmZDN3VnpGV2ZqL3BjaVV2NEhLWDdIY2ZtVjZ3OHg3NUR0L2pETHIrOHAvOG5WUC92MXpZZmxmK1VML3BpWm45cStmVE5YN1E3aU1MazUvN2Zmcld4eHQvNGU3Ky9PTHVjZkJvRDkvcUJzM2Y5WVN0ank3MUpEK3hoeGtuZjJPTmRMUFE3d2VqSXV5OWovcFFMbzZoSmRXTVlQTEkzbno2L3BLZW9qaDEwU2ZyY25aZkVTLzRNRXYvNGtsTTlRL29NUWExOTR1RHQyVjhzUndIL1c4MVhKcnhMbWRQU25DUDhYd2xTUzdGNHpZR1pvMjA1MmZKY2lWandUSThjL2tuNk51dElYWEg4SDc2QndCVWRRY0ZmVyt1ODVmMHV1U1dPOXI2ekN2OFZqZjgvcVF0UmpXVmViNFo2TGFiam12Zng4OW5iMTZtUy84VzlDcGdXUklGaXRXc2x5R0VwUlQyOEp1OUVzeThNZUUrdzZUU3k3N3hSL0VQMjF3b3UrNi92d0Nnay9QTVA3UE1VMHpEeTdRWFF5V2l2d1U3WThKUW8wbStYQXBOeDRCMUI3Ty9OQVovY1hITDRBTTljTC9HUU0yTVlMUE15YllUdmlnMU4wdTRRSkRtQWl3Z3E0TUF2WGRaSEJlcTlIeGxZbitDL2hOdU44Ti82SXlaTDdJZlgwZ0cxc2Noa3NIR1V3M05LUVRVcGVVM1VWZTYzWnlZZWt0amhRTXB5c3N5dkEwc2wzSnY3ZUYvM08xRjgvMVFhMlhyLzNmVTZzZXFmaVRkT1dwZVoxREExdVBjckJ1WlhjNnQyODQ5NjRYMzhsL1JHUE0wT08ySkZUQlkrYlFrdmNpRVExYVFIVDVWb2xadUFLKytXdEtVVU5VWGZRV0F0MG9adkNTNEFOY3QrV3ErMStXZ3ozeFdZVEx2S1pWNVZZa3JWd3JCbm9wWFRWWkpaZ293VjUramNNS2Q2SG9BTmE4dVdjajVRNDFnM1VsaTVialRUeU82V0F1eDVxWlM0K1FCOWNWaGdaSFB5YVVFalU4STFuSXVFWkRzS1R3TEFzUVh1ZkhZUTJ5WEFFbzBnQy81N2Yzc01PbzNyMm5FZTQ2T29xeEU1VUF3dFk4MkdEOGRsNkp2VVd4QmpYOWhjUUhXY2ZrUHRXbW1vcithdTcxZG0waCtHRGdmL1llQTZrZDJtWGM1cm02UWx2U05QQ0RUL3JmcGhVK05ldi8xNHh6eGtwUFhXRTlwM0VDVnVEbS9MTVY1M2d4K3NpNmo3bmhtM05KbmlQWnpEdk1FbE14U3VhNDBNdnlOVlFzMG5BMzVVbzdyQXVCZC9ZMVo0cnRoRjNJVjkvL0JCUERqcGwvWXZHS0R4RG5VaXpQTTlRTG55RFI5SXFUQVB6Q3M3blg5L3dadHFVVFl4TVF6Sm12RTJrTzVFYVNKSGRiZW5SU0ZyWmlncDVyZnREb3JiUE91b3NUNExCejBvU1IrNkxwU0hOYWZmdU5yMWVhcGYyTCt1Z0xJR1BEcDM1cG5OL1YvTU5EWmpUZHVtaVo5emIwRno2WDFJM2dia1NhSWlVdERIWkIxalpVSThkQUNuaDBFWXJHTXBsUjB6VkFPcU5GaDZPUENZWlhENms1OWcyTGRaZStHZ3E0dGVhdmN5ME9LcGZoczNXZTBtQUhzMjhaVGdZMEFocHAweHRvbStXelpjaGZvZWVMR2hNVSt6enVLc3ZRWDVlNC81VTlMWisxWHNqaVNQVERITFBQVHA4WkJnUFgreUNUcEd4ejVtdE8rWGp2eC8rNWFvalhLNUtXM2YzSlhoWE9mY0VKbnV6SFVHWFBJRWx2SHhpc1hmZ3YyZFE3bTdua0NYSk5mMDMwNUp5ZWVSb0dUKzJLYkRjZ1hFbUU3dmUzTW1yNnhXSDAvU2w2YXZ5R0N6dDZ0ZEdkdmNRaTVvcEZLYXlCRFdSVHpTVkVDOHVUVlBxMEdLNkJnTlF3WGRYMzZ6djhzYjNlczA0cm1adjJqbXgwNVFNTGdXc3ZHUkxTNHBINTh2VHVtNWUvTUQ2MlhEZi9uZ25DRklsU3Nkc2xzL1Y5bzVmTE9LNzJSalNxQVBmUmpQV1BCNUR2Q05jcXZZazdNb1k4RUNiTkNBMXg0Z1pzUzVFSnhsLzVwTUt4OGt4K2t0V2hGcWZSRXg4elkvK0hDb2ZZSGt1YkJYaG53YWxIUk9iWmNCdlJtaTQwN29ybHZ0ZSs4bGpzeUNhNGpiMTZkd3ByZmw5M1R4WUlXZlZyWlN0MXlPcktCVk5QdXdFUDVmZ0ZnWlRZMm94RUhWejkyK3N3UjNQc2VxOXpoblZ2SnY3T2VsN0UzVjlGN3dBQWN3bmk5UE1UazFaQlgwTnl2cDk0UW1zb0R4Z2dHYVNxRGwyRmorZmVZRkwwRk1HRW5zNUhFaXlsZUNkRUkrNVY0NFhHN2NYdFBtOTZXL0ZqU2IrT052WDUrVjUrUFVTT1cvMDJndTJ0azhuZGE4ZU5LUGNsdml3QmdZekYzTzFveUQ2UEFOT09zeExoN1VrNEk2bGZ1OW0vbzJwSElzQkU4VFVBNklSUXlkQXVzNVROR05neDVPNXc1Z0g2NnQ4U3JlOHlRVks4bkV5aS9QeU5oKzV3RUt1YlJMOWF4SDVLaG9hU3N0QyttMU4xYTJDcUtCY1pPNVFkSWFDZ0U1VUdvSU9iVHhmMkg3UEx0enl2aGNPbHZmWDIyT0FnVVlZOGFtbkJNNldKSWxjcXZFbkNIV3Y5NFN6blloY1hDcE9vWWJwdXordk9lK09yQXVaVEZVR1EzblE3cUN5czgvMEdGc3piMnFhY0NWQ0hSQXVJZlBzQmsxRHBndUN6L0VmbXFHL1h3L3NJa1hUTk10VUlRaTUyT1FjeWZsMkdMc0VKSnMxL29VSGxMaUxVcGR6aWl2b3UxemxNamZGcHQvaTNMNWtjZ01lRDlaNkZ6WURydnZWT3V6UXozUmR3TnVjV2dUanIrRE04NjAyNkV6RmdKVFlzQ2R6QVdlVGhXWUd4bThYaWhIMGFDWFlnWE9DZHp3L3BoczdTTXJ0eWFmUkxWbERKaGFMeGZ2QXFtc3NvWml1dzVxUU5Ta2dUNitSd0pwOEw5SFVwQlhtNnJsT2Z6TThuN2JvMjNTN284TjJmeUJJWVRJVVp1cVV0NkdOMzdONXU4UVdLSUx6bW03OTk0ay9VZCtxVlBzODJ5emJpOWRjUCsxYk81aStzRWh2YlJLQm9iMnNTeEtzQzQyS0xTV0xmRWtGaUtVN0liSE95eE1KbkgwTDBuam5hYnRlQ056MGRXTzBLODNqNzREWWthZHhFcDg1T09sN1JsZmpsN0pMR3lnRlhqaGpaNjZtc0J6cmtHQXFSdWVaaGlkNGRzR3BJVTYyY29tdHAzVVgvSlh5R29YWEFkZWNzK1R0MXZ6WUpUNTRybWgwWXVZLzN4UEJ0NUwxekJ6M1ZhKzNqQ0dlYnpPZEUxTTM2T0ErUWhhcUdET0NUdHIyZkJLVVNyN04wWk9DZkFCSWhqMEhjU2l1V2ltY1I1a0JHSHRIVEFRRmtLeDNGMDlyOGFTZnVydU9sUjlWMWh2TjdUY1pKK21NQS90K2pBODQyMHJadTdaZ1d3V1h6R1JlMFdnMXZ5ZXFLZ04rTngvdnlYcDYvSlE0c0hUMG5aUkNrWWVHLzNkbFBsUE5ObEJ3RHNCKzRGcjdHaUdyWWwyL205cTFFR2wvUmFTRHpKY0F0K3dZdVlCL1ExQkZ0TVJYenFxcFlqamNlSHVHRnJwcVFyNkFTWnE3NitvSmo4ZlRPTnhjakpDMkxUTjEvVjY5bmdPQllFRTBSZWRlcE1Jc0pzQVVJbVVQYjVBL0RORnFhQlc1dlZPT05ITWptOVRDMG9Kc2JlcjlkUGlEeDNBblFiY0hyOVNXOHpSQ0l6bGlKN1BCaVJydHRSTm93QWFFb1RSa09HL2JVbXE3RFNPUTlDVzNXaXJEdEZEd0RWSU9YVnZJYjBxVDRDUXZCa3p0ckluOXpuWHRyYXBmT1hnU1phQjE3SHcxNkY0NXA2bGljUnBXMlg3OEtjSys5a3p4VWd3a1NpYzdPdjQwN0s0S0tYUXRJWUJHZkFSTHRUTG4xNDhvenozR3pNOXFTWmIwcEZWWGtJN2N0Q2JWc0hsTUUyWWpOUmx5LzlHYzdJblhRWjRZanBDVjNnTFphbUFYcjBJTE1IRGRFSjZoZUVON3UvY1RWMHNLOE5LbmFKVDlQRU1pd0VHRGErZEs5MWt1TThmSGNnSmdoMm81SDF1bWZFVkNUNy9TM2Y5aFBaNFRyTzYxUUZvOUNyb0JWQ2dmdUNHZlFhNlJrWk85SzV4c0o2Ky9wVDdsRXpoc1d2SENYbVZZeU5ZcmRwMi9BMzZuUDBZbys3Mldya1YwWUhoTXN0UGlJQ1RiZG5GZGlCNFUzalVxdzI2WjBwUTd5T2d0WkoyN0tsVTdoVUUzSnVuSW4reDRHSml0YlQ2MTJaNUpkL3ZzMCtYQkFFNUxqNDhSUy9yVExzUnU5T3pvdHV2YlNHNklYNlJzVGF5cEZmUmovNVUwMXZzaW0vYk9peXFUNVYxZ09vZ2ZuQlNhcWlnay9hR0p1OERkQ2s0Yy9QZ2lINzY4aERpTTY4UmhoY1NORjF6MVl6OFp4QUtmWUxadXR3L3hTV08xbDZLU01BLzVvU1pjLzBWWHk4NjczVmN0alJFUnZOMWJZYTZTU0Z3RmlDS3doTnBvWnVxL0hyY3NRTDdzTC80Y3NwWGZydDJKNnhocWR3NXo1Yk9UaDFlQnMwVSs4Rzh5WTkvbVBVemVzbXl5a0x3RXIrOTZlOVczTHIwRmozendZaURVVlRyVEFNYWluaFljYVJZTktJakhoUVBHUmJ4amY4S1pCNEx0RmJ0YmpYR3pkdnc4UGoyVERjSFdDMjJheTRoc0VtR2J2WThJdjFQRDFzT29VMzQ2K2ZQY0NYdkFzczlPUG1tYVV0L3lERlpwbEVyOVpTRGNUOVN1QWJkUzRseGdmUWlXU2MrVjByT1NlU3A0SXZoQ3NDeGt1RjlLZjllLzQvMExubmNGTzBMQzNVWVhwSVg5aXBuR2dlNGx1QW9KWTZFd3NkV2RmZksyaFIwdHRiOGFUY3hQby9FQSszMGJJcENXdEpvQkFxcHpmbjdJNTRKaXpudkpUUmVudzBsNitrV2l1Mjg1Ump4STcxdnZiSFVHRDFwd283MEEram10REp6NGlhK243d1FzSDVVb2ZGdUdqNHM3akFNbmI3U3BBQVFPdkRrZEFtdjZ3NlQxQWJxRGpwOUR3K3V2MnhjaWFiNjBLQTVoU2hNdklwbnFXTHdITHVyNWpmTmZWaFcwcm01YkltaFJLQ09vZkNsbkIxamNTbEFIaU1WRm9nU2xQaElVL29wVXZBRnhkemZ5THBjMzBMRVBYeXQ5T1ovcGo0V0liRkh0RmRJam45dnRvZThHanZ5bVMwSnlPNTBRMnpkZU44bXV5Ri9mNWU3Nm00Vk4xUEdFY2QyakpMSEZFblRQMzJJSStpbjRyTTRMRkNJSGJpTWNvYVFMMU4xN0ZOSFRqNS82eGVoSmVFK1pwbTI0UTd3T1FiY2F2Z3dFVmo2a09jUThRWUpSUjRERTZ2R3grUGFac0E2QldVdGZmTmZ5dVpKMFdyY0M5ZkFnRWd0R3ZiZGdLTWJSSWh5UkJlZDR1dWxYWG9JbXRmVFhzLytTVGRTaUVKNWlobzBGYjlKL3hLLzZwZm5QV3grTm9yTkZsaDZHVWp4ZmxGNmFiMFBoQ3g3bkxCd1lKelhKMElFelQvdmdrck1tOW5ETk9DczBaaXFTM0hYc1E0YlEyLzIyQzBGNWR5TjN5T010MndQczlyN2VYK0h0MDBSMzRDdEtTOVZGTGRRR1hoVHhsRy9yMUpJZ2dYT3dlTk1RYUNadnlyRG5raEgyWWJ5OVZqYzkzMkF2YlpKTTR5V2hNajFUSTVhaW1OMGh4cUw2dUZXc2d3TGJvNEIxR0VSS3FsZEFhWFFYRCtBRjlGS1VoR1J5cDBSd0tJa25MN3dQdmoxVDdSSXdxRFJmVlVWQnNRZUZmWXNRTy9YclVlbGxGcVVZWWE1bEx2TFUrSWJQZmRNYmVKbWpLWFdQOFowdFE5dDU4MEpEY20vVGRZUDNDbHJSY3F4cklFL2MyQkd0aWVVQ0c1S1MxMEEzSVJnNnNweTZaTW1QK1JiTDF5Vk9OM1Y2WHpUNW9EZ1JnWlNrcWxTc0REeFdYYmMybmwxNm5hV0t3SWtuMTd5TlFpUEMwdEYxWlVReHBFWUlzd0JoVnIyYjNQZ25iVFlwbUVVTTlqK21HQ3B4cnM0Y2VuK3pZVVNJdDd3WUtvT3NWQmVzVlVxdTU3RlNFbUh2VXNvbDV5NHJRZWVuNnVRMkN5WUdudEFwRDcxeEFaWVZNSzRDWW5VSUVGMzBnUmZLQjlpVlhHTVg1ZDYzcmpRamgzcE5LOUJaOTQybnAzQktxa3g4Tlc5NkpmazlSWUs3ZmJEM0N0SFJjYnVaRWRhUlBJNGlmS1MyNytVUmxPT0VZcXpzQ0hFT3AyR2hyQXFzWXdyc1dtbkJ2SzRtMEhiRnZqcnBwOXFUUXdUeEk0K25seFcydDdwdmp4UVE0WGZwWEZnQ3pvSnpzMVROYkRRZmtMVE1zaDlMYXFDNHNGbmY0N3pBcnJ2Q3hEeWRXdmFmV095MXdxajRQeXdQZ1FmZFJNN0JCbDgxRVhrdVVianMvZjRxanhsZVJaaTAwNnFJNTJqcDQybGdOOW5ySFNscUI1V2FjS044dm90WjZOaktyWTBZMFV1NU5RaXVka3gwY0tVTEFlTmxEbVJ0aHh6OGFhbU5XYUxvUWtNZitkbmppVjVsZ1FHc2ZNbzNDYWZMT1F2OVBkZjExSHZKMS9hOFBjckh5RjR2aTBhVW5DL3pxYXJxY1BCYi9SRU9xdjE1RitMQ2tQazdXSUdEc0UyK3FoS0txUUxJUFBlNWo4SW9HY2IrU3RTUEx6cysyb1pBZXdaVjMxZVJKYjZLK1FGVy9ya1hyQlh1WXhCOFBESHVlT1hlTXBPSmRyOHc3WHdHd1g2M3NESVcxblpVbE5FbUVweFdnSVIyUVpaZFJ1Z1htK3EwQmpmU0N4S1Y5U0JYcHJvRFBJdFhwaE1xcEhkMzI2OUpTdW05N3pFMTI1MXM1czRjMXd2dDdkRmp0T0ZFcUljdS8zRjlWMUtldDBWV2xndmNZSjlXNHF1NFhucGdRUDZSTW9ydkdHaUgxRVY3SW1kaEZUbzVmc3F5Wk13b0t2clBJeWJ5SVBoYWFucnprSzNpYUxqZkpFU0QxWnRkdFNZdXZBek9iZ1dKclFVRldEWHhiQW1lYTBwb3FUVXd1Z0RTR2ZndDIzQUFXbGl0bWorMnBFM21yc25lS29yQzRacER6RTJVSzd5dXlWOCtUNFMrOUd4Q2JKaVZsbzhBb1dUdXg3MXRwQUhZelBBditZc1ZOYzhRZlNrNTVqY0ZwcXFKZ2wxd0hHcWZCSVVVQ2p2NU1wOFpJUjZHdit0UXdwNU11SEc4ZzIwdmQ1enVRUjIvNHd4Mzk0bnRlcjh4Tm9uaUl2RkMvSDUrNmFZdFg3RnVBYUtJVEpDcVVxSnVnZGs5OFZQZHBRWTVjNmVCUnpOQlVTd2NWWU56UC9zYng3RTJ2UzBEWWlhYTNXaW1nb253dzBzKzdndWlqSElYQzVkRWpQY0VvTWErRUlOOW9BSVBnVGp2QXl5eDZvTUV1b1RSZDN1ajQ2Ry9rWkVMaW5uWkRxRStBYW12QzNYeFc5MTl4SlVQWGk0MlJsN1Z3L1ZKUVRrcEdEeWtiOC8zVUlYK00rdzJUeHUrbDlkL1NpWFdSWEdCdkRJa1RRUG8zSys1L2xZc09Rd29WRGdDUlJ1RXlxd2xNUVJFWFEzMDE4WDcxaFMvTk9TUjNEWi95SytBVnJqeWJ1SkdSYmVxN0NNYlJSaSt5c3VUUnNnb0FMK0hOdEo2WkFCWHhnN1ZXQU9wMjd2bzZyNXNnZDVUNzVJRWNYcklaYm1hNm10dWJzWlNlRk9DeUFiQ1V0clk1NDF2WHgxK3pZZjBrUTVvbjIrKzZUdStOei83QjlmRnNwNkZIOGRCMEVJSWp2U1lwaEgvNEsvcGVtZGhaS1NFbENKSnhodnJuVGxIL0U3dWNTLzMrU2N1SDJMb01ZUnBpcGV2OWRHaVN6NDRRMm9USGNsS2p4bHBnNHRnWlVjdEVYc3lsblZkNHZJbVZOMm1CcmJkVjNKUHRLY3djUVdPS1BWTGxjdTcxZHNraFRlUkdtTzBOR211c0kzSjh5RTRNbDJhamxMQzlTbUVEME91WFFwdzZsWUJVNVRtWS9wRTVSUGM5ZVFxSW90b3JaVXlKMkV2TnhWdGI1VFBiVWdhNUVCakswT0ZzbFFtLzNwOFRqWW50dW1talRGMTIzQkJGNXZDRVg2a0RSSURTWkp3M0FJa2lFYkNWVGlPVHdqdjJiejR5NDVCQVkzL0ZFSUJ5bERlMG9OZGZDSm9Jc0tpMER1a1k2SHJsS0ZuTHlnT3QzdHB2V3pEOHZjbkdFazlBWGRyc0xySWFnakV4a0FvS2xUWVkrVlpDUSthcmw1dFk2bE1jSCs2eCtWZkhCbnZKbHNDNUIrd25jVm5QekFHcU9YN1RVbVVRWk05bkVtdk1vRW9MZndyRDh2MDk4WmJlaGwrWTZWNnIwdjd1a3lQamhPaytBakZrSDlnanU5bHpOWS9oYVdtWHg1Y0pqZXhHQmgrUlhTWklFaGdnSUlsSVorUUJxRHNaTFhLYjlZVjhlSmtub1N1RWt2YTNHTCtlYUo0S1BmV3Z0NkdsM2VDMTRkTW5HTXNiN3V3RzlEeFYyU1BrNjdZNkFOdXNkWk4rcDBoYVFlYzZpemovVzRuby9FNEpuSnFhY0taYmt1cU5wOTNSQStNeUNQcFppMjE3TDNzR3UrSFNIbnRIUExSZStZKzNyTElQWHhuZFQ4VWpyWjR5Q2s1KzRPSnRTKzRweEN1bnl5VU1pSXhub0NIVVU4SnFJYkFUWE42NDBQODZNYU9PWkp0Rnlxc2V5dVU3eHhvb3V4RkhzM3BMUEp2eEdEODgwWWZlemxsUyt2ME15SzZISEtmRlpKalVqc0Nabyt0OXhkUlRkcnE0Y1VuMHIxZXdmbkRBd2tXSlBSVnVOcVU3a0xmUk90NEt2c1hRanMwZXhvMlJTeWpGTnVKdTJnREJIOXhCUHM5TmN4QW5BbTc1YitBb3poZUJaLzIyeWJhdEtFV0J5anM0SU9SenEzRTc1VnJiSXl0T1RZNHRwSUt6U2ZldkMxT2tacjd5UzErR3FqSDdlcVZLZ3dRMVhnOGJPUU1MR3R0dk1aUjAxMUVteVZMc3F6RVZmd0VVblloV1R6U3RPRDllbXhRMWJHUDJuVmRwOTB1TnJkc1liZlE0Z1dod1AvYUlvc0V3S2NMMEVNTEhZbkU0Z3NoYXJrZldPcGlLbU0zeEJ3ZWoveVR4Ky8rSTFDQVNMSVBCUmNhQUdKZHJoQzMydEV0SGxiUDVZazFuQ1dWUGg2aU1IYnZyLzlWVGMvL3pKZE9zTGVqM2RqZEJPcWphTS9JL2lwb2YwNzU5ZDlnQjYvU0FKeWtQcTNITlQxU2lnQnV1eE5YOHVIYUYzRm44YlN1ekZKOWxveC9ESXZOZkhBc3k0QXFUZmk5d3dWSyttQk1Tc2I4U2FYT1FJREwvZUwxQVRKNVNBbFpiaFAxd1dqOEc5SFgwV21UU04vZmlIeDdpaWk0bEZuM1VzNzRYZVRURDByWEpibEFOakVSdkJvdGhnSGhZY1hMNkVRcGt6NHlTLzg2akhkMXgvUHBXYmZaMkF2OHlVNTJQN3NiaXJuZVNKVE5kKzN5VUo2akc1dGpIdDZTUFJKa1J4SDErWHkwSlFvYlNWUTZwaVpOM0VjaVpya0VyWGRycWhadFE5b3hvbDFvUmtvZWJieUx2c0VmaDhvdlcrN2hPbmJadmd4bVFTc3loUXo0WEJ4YXRIb3VKUDIyOS9kWnVORVJjSE5xUGtwalc5ZHBRdzF0SktzZTRVdXhuZWdSR0syK1ZPZ1E2MTNkVXFzY1k1Q3VFeDR2M0dlZnpXckxyWUxsaVl6aGM1SlFYd2dHOGtlMFh6QzZ2OGVjTFZkSjlWS0h4R2E2ZUFUTkNvV3pRMlY3YW11ZEJ6MHRUOG1kSlY5b3c3T295SWhTS0U2cjBpSmQxQTRONVdCU1YzWVlXOGl4QTY5Y3BETUZEYUVreEdJV0RUcnlaZ3JPM1lzZEhtN0krZXdMa2FuY0JtTllRMEcxWnB5bFh2Rm9RbzZDVWNzekV3VWdFaUxuWFN4TmEzMzJHSUw3amNseGJsSTE3WE5IbEN5SVJpaGdKUTJGS1JCbjkvYVptaVE1TkUyc0dXZ245d3R0dE03NURseFRIcnRiK1c0NUdTNlJ1dmtRY0xrSUpXWkdUTTBEVFJEaTdjd2pSQXJEYXhjRUp2MXlPa2w0TGtGQkg3NlpKaHNKSm5ES0xoVkFEeHJudVdwbzJWOWljM3ZiTGs2TjdTQzArd3RPT2VnSy8vRllXNFF6eDljVjFWcm1LUmhxRVd1Y3VkaTBoemxuc254NXdVbmpteHRreURaN0llck9jVlFCa1pmbXNmTWtTRVd3ckh2SGMxd2F5SDBORU1wZldBalNob25rVmdtM3paYkV4K0V3ZzZOaVBXU2w5Q2lHaWM2N01Ob0I0YU5YcGFPSVRtWHBUOGNWVEtuOXZPTGpvMnNFOG1EeFVEU3J1RlpPU0RkOUZjclNjSnhBcHhKS0ZWT0lWeFhobE15Z1kzdnA0N3RmZnBBcmxhSE1QRi90OVNZZXNWQUc5MHVCc1BET2pkMmdaT3NPSjJHbzdyU093dVZtdWhqaXkvMFZMZSttd3hnTHdGRWxjUnkrZ3lDSUl1STFiMXZraGlJQnFZQzRicHRoVlAydjlTQVEwWjV1T090OVdwSVZOUVpvMCtmVzcxZTlFR3hHSU1TMjY3UnJHOUY1K2JmKzVRb2d2azJXMFoySWtkWTJ1SjMreW1ZVGhvSnQ0U0YvVE1hUy9HUkZzYlp1dHkzZE1adm0weENCRTRIeEtXN0JVY3lDQ3NKTDJZRWkxODFRR2lPNG96MmJSam9aU3NBaUkycXNFTHlZdVV0ck9nejIzZkRxVW80bE90ZVpVY0lJd0o4b0ZNekJSYWNMd3A0Q25YUnVObTBXam9hL2tHL3J3WFpVTXRFSC9qY3A4bndFUU5kK2paWmFBS0FlNTNXUnNmNE1DUjB6czEvUlg5bUtqU2J2T2k0T3R6VnFRaG1jUG96U1FBVGNJMlNFbkM3YmwzaEdGWUJET2MvVHVYMGRaVHlmcjc1N0xrKzA5VlhLOHFpbVdia25GZjU4K1ZrcGYvT0tlNHBPSkJDVDN4TEpjbzZQd1J0bEFCd0dpUDZYbm9jR3J0azkyWVhYcmVTc1lZYnpVOVlIUlN3QldRWW83bWdXZUtUU01MQU1BMWxTc1cwTHpWRU13K3k4Y0svdkJJd0p0MHVYYWtmZVExTUV3dXlCVCt1RjF1cU9tMXpybW5wSExKNHVrWkNkNVVQVlJTSGxTbkc1OFF3em9jQUdKSUZpTWtGb3YrMXFIZ0g1UXJoRzZqTDJROTRYOFYwQzZsdXVuMUoraXBNb3RsQmNZQklsS2RrbnZlSyswY1NZR05jZU9BZFVuek1ZRUdidTRCMEpIeGRwTUY0S0lnclp2UmQzU3FCZmp5OVNCTmF6SERLOERCMkpXM3R6UGFOMGV6M3lQSlVKOUhVWUtVS011eXZpcjBtaEtTaDUwSlpIZWhRUUtXcjJEbkZtL0VMUDBpVmRNSXh2MzFKaFdoUkRpVWxKS1UxUlJWdjNvVThNeTVxOUhDN1pTL2lJd3ZGYVA0Y1V2UzB4a1NhQW04Y3JGT1hoQ1J4UTZWclpka3NweFd5MmttZHR0aTdnSjBtMWF6N2NFdTVWZ0RRcjVMV3JKMHpnemVyMG1tR081ZXltaE13WWxBOUtsZGRRbjVCYUlNdmltSys0T3ZwN3pvNDBrcFh6RWZSaGVaUnZ3RGdCQUpOUWhnMVlnNzZSdnBSV0lxbHRmK3hTVW9Id2RUVVVzdFBVTkMwRlJxV05aUW1pWDQzZzUxRWIvdVgydWlDRGZQTkd5b1Zza0NSNVBrdVg2L296ekt2elI3bnQ5M0N1SVYvV3dhVVgxbjY2UUZIRFU4RjJwNUZ2ckQveXBXZ0JtNXExTmNXVUlpQkp2SFBUK3huTUZCQ1pUekM4MVZUQjlkcjJac2ZiZ1pUUlBBclliSWJXdENKcGJ6TmRtMDZBZk9Jc3piVVhsMnh1Sm8vZXQ4MlZXRWRRdU4wSWJ6WnBnamk4KzhPZVFIemtWU1BtL0FyQzByZDdoTHA1SzBQd1lMaVFZdHhiaXlWbUQwbFZWdHh0L21NQTN6eXp4MVc4SmRFUkhYUldJaFR1NUh6NC92VzVTN2puRlpuMVVEVGtERjlYOG0vbkRVamhTVVQ0eDgzejllWStPeEZQbHFIcEhUZDZqeEUweGozZUpWd0grenlub0J6ZnVWbXlVaWs3OTJwK2RQWGViN3ZGTzZOWkZxZHNpS0ZKQm10dmpLS3dWalRYc0pqOUJLNStnNERyRVcwMHVTTzlBc201dlMwSkJYbTRGSGxPVkRQcyswR2JEaStoZktURnI0bG90UGh3Ukx1Rk9OV2lZejNINmxpV3hZSjRENkhZRmR1dDFpS29ycDBQUmtSbS8rcWxXRi84MjQ3d1B2emNRUExtaHBrbit0eENEMjlZSUkvUjhiS2hFVUMvbFZMdkZNUzVyaTZGQ1BZcjRwUFNwaVo1blFqejhjRmhWOFhvL3VqTTk4c2lScEdKenUzUVh4aWtUajZsUjFuOC9sQUpGTjRMbytTSnhOTkRXOGFyNkxSemFzZy8yMnZBV2hoY3ovdElUK29nS05WU01yUDFEcFpkZnB0OEJQbXRvNmxlZTJkWVNDdVNiU0dwR3lNdldxTTJRbjlFTlhnREFXT3p3UjFIbllCWVI4WnQ3WDJvcjlLZ0Ezckd4eDd0SHBJdkVNb0VINkhKemVPTlpIaVBGckswVmR0R2l3eVdwWndoV0Vra0V4U0pmV3VndnAvNDNTcThtNVN6NU5CaW53T0VyUnhHOVhNejczUTBZeEhPTE03blk5K0VUR1pGU3VnVHlYYStva01VZ09ORGxSU2Z3dkN1eHU5UWFsV2pMQi9NR0ZUYkFkbjBqZm1mZzdTR05OVlVkTTluYlNMb2MwSGdBTEhVRFhXL2xZZFVQWE9SMFlWNmpzUkxMUVJkbXlpZXgwbVNmTGVEeDY3NFJDYkJkRE9PN040OVQ5dHl4QjNVdDlZNkZZcThPWGRpM2J3bkN2M2NJRjhnRlZTclppQlJ5RmQxZG9VWFFIdHBWdjkwVGhqcmFQcTV0bkw2Z3JGR1QrY3oyaWxzdGpUNVZnb0hFRW9sUEk1ejNzc2JCRzBDUFFSMGE0enc4V0R1a2c3VnBsQkoyalRXQlFTaTQ5QkVZTjU3c0tsUEovZmlOQytuamE2YngwTUkwRWFCUGc0WGhyM3kvSmlGTkFOZzd4V2Vva0wvWXhMRlk1QnI3RjU3eFRjOHVMSXRMOGlId2J4eFAwOWgyTmNlKzU1R05tWHBvVVBDTkEyamlEUzQ3dzRYVllnelVyVW1rQTFkdVRGN2RxMTlUTUVzUCtYWjZVWXZCekFVS0krSWZkM0xXWHljT0xndkZTbGpqMFdNVjFDY0d1V09uTG1PTERHTDEveGdJb04zQnIzcVhzTzBmMlRsWmJWcEdERGprL21HQmRyVzBtWVZQSWJCR2s5Rzdza3lFeWk5dkRzZ0I1aVE4TTh4dGJOY01jL2hCRGdJZ1VHOWpmUHN6TzNRSUJyZUVzK2dwWThBd1JSMjFpN2huUVV0NHQxWVhodkt1MkUwVjUzUHIvd3V6QXhJWUE3dmx5QWFZL1hHT3B0QXVGUG1WazdJN2VmNUJDOFZjSjlRN25vZEJscXB5blEwVjg1MkR4M1ZSWlRrZWQzUUU1ZEN3eWtYM1VkQWdyQWRSQm5lK3V6YmEwamc5SUhnVCs3Z1RlL0EzRFZ1RjNmVHAzWWZQZTQyR3BobEtNWWVBRGxMTmxEd1ZFS1VZSmNlOWZPa1k4ZFJRRnMxTUpnYzRlellzY2ZTZ2xYV2ZiY3BkZlg2ZnRXd2xFdnA1VGlQSjNPUDVGNEpYK1Z5SEF4RGtQWW9DR2RLeEhJcDdyKzBVR001Rm5hNXE3d2o0b1llTWFHeWFuK0lUUUFhOElrQVcrbFlxVW50SWJZRkFhWFA1UDZvOTd3S2NyRXMwS2JoVGZnK0pmRitQZGFpVllvdkdNczU2QVk5Y25NaEd3RHh3cHlXSFh2d2J1aE1rT2JFK0twS0NwNkVlME5Ic2J1cTRXZE8zSHJJWGJqbTJ3a0FSVktrT0ZENHQ0ZXJ3SEx1UGozcDdzU2plWFlub2RZRngxYmFuWWNLR0xQNTVaaVo3RkY1SmRSS2FEaXA0MDNNd21IdXNkOTdscG1tYjNPYlA2TWJWVEg1Um5zTmhhWnBwMzBYSlZDNFBvYzd1K3JwZDRVSnNtcFlRME5sM3krMUtiZlhKTEJQeHlPYUFNZWVYdURUcC8rMWs2aVowdSt6cEkrZ0ZqL1ZiZWxXZHkxOGNINS83VlFMcmFXMmQvUFpIOXdlY1V3cW5XVzYzUjRNMFh4MnlwVHFOYkNIOTB3QXhSSGxaRXlaNVBYVXkzRkJXUGl0RG9xbjJ1ZTdFYWlJZTRBN0tPN1Zkc0R4MldwQkMrRW9wRktKSHhMSDdlT1BobHlXRkQyejhTMUo0Vnl2Z2R6enJ1TlhnN1k3Wi84eTFYR3ZLZ0NsMDdONzM5WHU1L1NUUmJ2Wit4VHEzb2ZQbFNuVjJjY3RNQnBURGgvVzFlYUJwYUx0NDh3OFRXemM3dWZDL2c1bkUwaDdLRzNNYjAyZmRsUnlQL0VQUjB5TmF3WW1HOUgraW8vZlBUeC9Hb29BWlVsYkoydlhDcVdzazlXWnpFWkJQTlV2T3JTa3pkcHRHZTNrYlVScUpNaUNsWnJYb2hMSkVDQ0cyMzV4SUVLblBmZk9VUWFwZkdwVGJXM1cyL1hNRnhSNWJ2STZya1hZakhGaTd6QmtQRGtvb3lDQjloK1ZIUFVmN21zRlh4enR0bnFsaFpYek4vQjNJTnlsME03YlVtOUYvZGxmN2dmN2tqS1BKS29Edjk4Nno3RngwdmtCN0tkb0c4Wm4yTWJDN0QxOXZhOGY1eDVNQkxPSFFCR0ZWaXJuTjJHSUxYaCtwZ1lHemhYdkllUlVzclZCalRTVHRKVHZjSFJpMFEyUW0zL0JzS0hvTGVCdCtVM2dJdElzaDJTOSt4M0lwZXJzMWxsU0s0R2tKMFRlTkVkeXhXY0cwM2lEVVBoaTJwZmhIeDNVbWR2NjgzU3I1U2M1MmpIRFl5NjN0ZnErV0Z3RFFMbmtCWlFWMHhNNkhDQSs5dXVNdUhIb1NZM3hlWDQ0OEx3QlVCZ24yenpQcTFtWlpteVg0U0x5RGhkMks0YTlyVnlhZkd4dk5UL2xzZlpCVWJiLzFrU0hONFZTMHFIbkdKbzhiOEw4aFdMaTIwcUtWSk9wMUxnM0xFVW41WUNKbHRUbFhlbWFtWWNhYjZ3TjhyMXFGUk5LWUlVSURQeVh6c3FLaStLY1VzTnBzTTFSRWZ1WkhpYm9vZHhlT3VJVFQxQlE4SjVERzhzKzJ1SzIyQkdMSDRWT2J4N1F2ZURuK1hORUhGNFpWYzc5YmtUcE4xUXZMUmZtb0RoV0xkM3RXZUVhcW4vd2wyR1NlSlltWDJKdUNNMng2R1Q1eEIvMEVFQlBIMUE4S0V6cWNPTVJMS0ZwSTFHU0MveERLbjRlYzZqWVpEZmYzaE90RDc5VlJWS3JkMlBvUG5nVnE1NUgzT1hQNmZLR1hYaU93K1plY1QwUzRkNDducEpHajN5NEFWa2dIaU5hOTBqaW9LZDdqZEJYUnVUY0RJWm9ZUzdaNjhiK0hNcU1nLzJ3NStGQjNaOWFIRnNmYklpT0FCczhpeURDbTBMa3Q5M1h0YnZRbm1hbzdiclJLa2RHRk45aEZIRVBzcTdqNGJtZHdEZzV4ODNqdDhCcktuMW9EYTRleVhEUmZMM1pGNGRaL1E1SzhGcmYxZ1FzNnVmOEFFRnN5ajFVU1N3VjRpU3Z5dUVsWFBEY09mR3hoS3VWNVVXSXBYU2FFc0t2WnUxeElkUSsxTzBVV1hQR3BJYlN3b2VvdTl2ck5zcUs4ZEpybnRueVB3VUh0dmRBUGpmTWI2dldqTllLQUZFbDBIYlpsRDdlbFZvWlh4WXF0YVZnbHZvSUQvdnhjYmtKaUc2MXJoMFN5MHk0ZnpmMVlwd0dRWVBRYTZOMmpUZ2Jib1A1K1NMZXJBeXRjcU9vNzBzcFRZWktkS1dQYVR0M2NRUmowWHlHYjJaNEhBU1pMRFhXeWppdHF2VVRnZElDUWEvNFhrOTdoS3FKOHpSSlFYc2g3bHZLQXdwNVh4VnFUNEtIQk5VNzVJWFN0dk9VcGFtNU9lYVQrNlF0SHU2eDA4MnZVWnZvUGtoMkx1RDZieXc5WCtINmU1Zm92Z3pjZEVIMndNMytGNS8yVzYvTGpwVldEWjI3ZHNPcGtvQWlHTm9MZ1lBaWNNamhpT09jMkgwRVZ2TUF2a2ljcFY0WFdlS3Y2SVE1eC9PVUhYTGtnQytMUHFtMVI1UG1LMXRhY1RiRkw4dG0wT1hQWTlrUmJ6MzJiWllpb05aQ0taUTZHQVZnNEhqRFZGbDJZRGxCSXNlajV3WkdrbmR0WUhWdlBRTkhCdUpKVXBWN0I1U3gxSGI1RmMwWGhBTFZYS0d6YU00aStuZThXSXY4ZmtQM0JkcDF0NTNVeXlDYTZzdWJUZlNBYzZ5bnh1VlBSQThRVkoxREsvSVhkK0svVDB3YVZ4RjA1dGVTdjNJb2NpVWNzUWdDeC9FUmlVZk9GZ294M09mQkRmV1o5dUdha2ZZOHNudlA2TkxjK0dwRU13cHY3MTN6K1JiOGFpVXBIUUNlTnd6WDE5UjIzZ081RFNSckQ0YWkrRmxhbDY4SFdiQTlaRGhBRUQ3RDErM2lsdjFTVkR0cFVvV2ZDZ1N3bmhDOXEvQStHTThYaTlxNCsrVzF5OU5ESnlSWWhRNFozZ21VS3VnSmZlSTJsTXk3bU5ENk5kam0xLzNYdFdBdDJCdDh5MGs2TjRBcHRXMG9KeWd1WkdjQ0tTTHozbWlOang3cGdlOGlBTndtaVVlNmtuWnludWlwNE1MaEhqa3lGNXNtMDYxUkN3UVB5c3pOT1JXZ0I0eU5uVWVyS0VUMFA2RHZGQmRieGMramdZSXRIb08za05mM29SUnNDNEJWVXFRSmxkMkRoN0d1VGIwcTJzUjA4WUVJMHNESTFpQUw1TnExTlExT09hZHlQOCt2dy9XQStoQ2huV0VmMmxHeFVrSmZlelJBRkU3ZVc3Q1JXQWJwTzRmNW13WkRIQnhCM3RwOVkvRHBpZERkcEJBWThMdHlsZGNwWU02eDVKaXM2WlhtcksrcEN1bmNoamUrOXFTUEhtZ1ptL1F4U3RhdHJaLzBjd1M1dktYVGIyZEFheTJPRE5WUmNGcStWc0N4RmJrRFdWV1BrMDF2bm50TkJTZDJIVTR4eFNLV1RrYnMxRTE4RVFIVTBoYmtkdVRxUlkvRXlKekd1ekZaclhvaU44MlYyZmtyOFRCSTZ4SGc5T1VVRE5nRjhNRjNCZHlveHZBT2xsOFAzQ1FTTTcrSi9US0tjdUVWMXBxYzdjZDBPeUI1SU9GSTU1N1FTK3I1Q0tFSkUrbHVkZTBydElOSXczVTEzMWFaejlLanhhNTJ3MFNwcXl2bmsvRGYwcnNuSFAwa1pxNVhEcmRQT1hUYXNCWnZHQ3JiZUFiN1RYNEkyUHhScThyQVNFSnFWcndseHA5SFE1NnQ2Z2cwWHBuQjNBeGVXdGcvT3pvVVYwWlMwYk0rZjl5SjQwQW5TN0Z2dktWbmlKNmdGem9DRm9LZFRSU0R2RlQzQVM0VHpPYWlrYnplMTA2SFM2dDRLUXhhOGZQZHhLUjNiU2VpK000eFF1NUlNdWdXaGJIM0s1ME1tbVp2SllubDM3S1hsS1lWRlBsaDFDNkFLaEVvb0FPNWdCNXNpWk9tMnRBclg4TE9kVFlEZUwwVUV2RlRSN1RWdW16Q1dHbWc0WW1LVytWTndHbS9xUjBSS2ZTNmYwM3I5ekdZT0hyeUtXSEhBVzN2MlpQTCtoYTNNV2g3dUJHK2IwVnVwVVJBZHQ0dXVtQzg1TXVyUitVSURnc2U0QU9zVi95NmoxWEo3MXFIRnhqakd4MjE2ZjduZ0lLbzlwNXVkQ3NzcUFkbS9vMFE2cE1uMlJUdXFzcDB6RFBVUytBOTd3WlU0SDJSWkRQYSt5OEFEUkxJKysvMVdNTDV0cVZiVWpCWlVtUDEyTHJ5M0VHeC9YUG03TGtIaGJib0FLUTVzRjNjK2ptcjAwS2V2OUw3OGlnS05IZitWNEtNbGtPcWszNCtsTUI1dFgyNzZTbnV1TDVpMHdzM3RPOWlwcURpWkdURnd4QndEYnRZbURlMGtsYVdDSlozNE9COUNSWDZSbUZySUhEbGRwL2tmZFZQek1IOUl3M2tYUTVkTVlhS0xiMUxSUHFzN0pqOEtnOXU2QysvZTl2RXdXdnA1MkJrUDhDUzRmWEJGeFRETExPanUwTFFGT0U0dWMyNHdrV1lHNms1OGxjMUVBYzZPbzNab21QV3pocUYzWDJiVCtaeEVsV1dCenBqLzhkdjM5bElUUGpObm54bDhiNjJMWG9aRVR4Zi9zTzkwMktvNjMrOFFvbWhkeUR6NHo5OVV4UC84LzNQL2xEenNjK1hMNFFqN0k4di9QRU82Uit2elA3K2MvL24rNmM0d2YwcXEvN3k3dW1maGZIdmQxN0xQNXYrNTN1aDZQRGoxNnVoL3g5ZUV5WCtyM3ROZE41UVhEaDYySFhSMWl3aU9vVlBKR0cxcHlwMEZOd0tFMnJHU0ZXdzhJbXY0UnZ2N09mTkRJT3VTMnR3NkxWQUplOWpUUytzampVWFM2VnhNOGlNekU2YU5FOTZTL3QwTXh1d216Q0NaMzFhNjFyMmlUUjN0Si82WVRabHJhdFZGNyt6TVlQM016MmRndTBSOGRzbm5aNm5ZSjFkbDBENVV5N0pKMlNHU1B6WEZoVjZjNmxMQnhZSDdoeDV0SlNvUEI2SmdoVytyVEYrMDUwdUgxMFkzRmFZSDJ5Ui8xMlA2cUU4ckI0bktHMDEvV3RMSWl6UmhDcFR5L0puM0o1OFdqV0ZXZWVPUDBUcU1QdDlNWnR3TlU4TXM1NFVhY255WVQ0cDNLcjNQOUxka0NCV2lsQ1JpZFJsUG5mQ2FIemR2TkxWSW43WGZlNS9wTC9yWXJUUmxJUWh2ZGFIQk9VU3ZHYWkrNmsvOWJHSHVQK1IvdEUyVE9YRGFCd3NrWFRZdmpsYlVsU1pucnhhVnpyL21mNnUvM2hTRk93WHJBZm9wOVR1Um1QOXJtdk9mNlovclh0aXFDN3h1KzNGZ3YyeUxsZjR6NzRENXdUV2MwallmOHBvNVBOZDYyVkt1blNpdm1DNGlENkp1ak82YUdKd2p2R29jV3JqK3FmMW9iMjVGUHBUREZVdTlDWHJJWUhWOU1yWnZGNnoxWlJ3WE1wc2VPRml0VHNHN1luR2dWbkVqaGxOaUJtU3MxcU5hNXFYdVQ2Z25lRUhnL1ltNFh6dFAvVk9pakpyT0EvRUR2MkZ3ZzFKaC8zelI5TnovMWZIZjhLVU5Ed1RmcytrL2o0dWZvY2U5c20wbHRGUm42VjBOeVh3NjlPMGxDbnAxNFBvcm9RNG9DOTFXOUtNWlJ4WVd3TEhHajMxemE3REpsZGxGdmtiOU40ZDFxTWpnbDkxVGRpZ3AySm9EVmxYdXo0OHM3UXVwM3hJT3ZTTlYyazFiZm53bk5WOEFqaGVRRnNuSUN3UlVMRGZtRlVESEphVGNOeHd2ZjNPSXg4OEFmUlZRTUsvLzB4L3J0VVVBYitQOGhTMExiUVp2SDRDT0g3cWdHMys1R0g1OFJEQkJiOUh3T3QvcExoWnczYWduYzNmZVhRZmVBMzYvNi9ydjFQVU45Z1hpdENsRU5PbGxFUjIxYUdmNkZLSmZJdjZuWWYyRFdsWTU0UjE0Rm93eWQ5NTNJRGpoWDRBUCtHZjZVTkNOaWxYUzJwLzUwUGtNekNmL3I3K080VzIrKzFQdi9JL2N3M2J1RkQ1QzVhL2Z1ZjExV3owOHRjMStTK3BVLzVsRGlCZVdWaitQaERtOWZIN21CODFhS0krNnZXYSsxY0UyUkt0R3hLQ0tsT1YveVNEZTBFRWd5c1lXdmxFMWtJekFhMzhheGJoREZGbzlQQmpIcjhzaFR6dUJkTVgvUHNGVjZ4Ty9zNWYwRkl3NytBdy85Y1VYWU9JWUY2LzhuQTFOaTJHVXZqWkVicjh6c1B5RWxyV3hIOVorSS8waFQ3STJ0VHZQTG9QYXB2NGZmMTNpdnIyZ3FzUFdnWjlQQUN0ZzFKb01RbGFGMWtSNWsxb05laDFCUFFNTkdiaWR4NTZDb1hHUi8xdTYzZGFvajdEV1VmalEzazBEdFRIOHJjWC9KRzIxei83ai9JbTlDQWRlUWtxaHl1MXhIL240VGhTMkRiNklOdjhtU0o3VUdoRi8rUnI0Y3EwRHNZQ3JJNzZiazZrc2RRSk9KLzEzMVluWnhCL2lROGM1UDVFZEZIL1BZVGt6OSswK0QvSFNNai9nSkV3SGJ5dGtOWGIzNWdKTTYzb0p6YUVZaHlXZjV0L2ZsOEVjanNNWno3SFB5K2lMdjdtSWY4czdQSmkrV3NWcHZ5ZC90d24rZmNGNkFiL08zZisxWXIzald2SXBURWtockJ6WENIYnhycjRnMWdSZ2VWSG5xNUxqWDRhQS92ei90OS8zd0ZFNjMvNjhDL0YvOUpYdElXTjdQVDMwdjhwMDYzZHZ5L3A2djltODhJMDdoSEJISklaSlo5enFYNU1QYWZmK3JQODc1bndYM3Y5UHo2T011M0dOVU8vTjlQOVd6NlVOZm9SQ3F3YklhLytyeG9Ta21qL01sLy8zbi8rblJpQVVJUEtxd1h5YzFMQ1lYWmV2bU9iaTJNM2ZtSEpNQTVJSXhSMTEvMjdvajljS1lYUWxILy9BNW5RMTFtR2JpUHNWYjNrejArY29udnUzeGhaNHp1dVE0WmtnNFQ5MmEzL1g4aEhZdmpma0kvN1YrRDdzK3h2d1BmSHp4Zjlsd01mL2Y4T2ZQOGpHTFhPdjZCSUhQdlB1aUNQKytWNjgvOEFQUDIzRHZBdk9QdmYxK2YvQStqM0g2SEUvMDNvOEYreFVnbjY3eHlGNVA3N2xpbzZVdjd6aDd0K3J2M2wxODlJK2Y4QiZsdDsvZGlhZ3JhbSZndDsmbHQ7L214ZmlsZSZndDsiPjxkZWZzLz48Zz48aW1hZ2UgeD0iLTAuNSIgeT0iLTAuNSIgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSUFBQUFDQUNBWUFBQUREUG1ITEFBQW5ra2xFUVZSNDJ1MWRDWlFWeGJtdVpsZ1ZCUlZ3QVdYZlJCUUJGMVJFSG1yeXNyZzhqY2FJbWhOZlZKYW9tS2RpZkNJYUVJR2puS2VDY1l1ZW1FU1NtUGhVbEVWalZKQmRIWFpCQk5rR2hFRVlZRFptNXZiN3Y1Nzc5LzI3dXFxNzd3dzQ5eDJtenVtNXZWUlZWLzMvOTY5Vjk0Nmo2c3NSWFp5NkhrQjlxZHRTRDRBanZOUUQ0QWd2OVFBNHdrczlBSTd3VWcrQUk3elVBK0FJTC9VQU9NSkxQUUNPOEZJUGdDTzgxQVBnQ0MrMUJzQnp6ejNYdUtpbzZQR3FxcXFiOHZMeVdqVm8wRURScDNJY3gvdkVnWHQ4NEw2OHRqM2pjM3pxaHpmd2lIUGJwMzR2YVhGZDEzaWR6WDBjcVZRcTlLbWZtdzZpclZjSG43aXVyS3dzYk5pdzRhdkhIdHRpOUkwMy91eGduUUpnOHVUSlR4S2pSclZ1M1ZvMWFkTEVaN284R0JUOHFZTkN2MmJHTTVCMElFaUcyc0FSQnd6VHVjNDRuWmx4NTBrQUlCbHFZekIvOHJrOGlQbXF0TFJVN2RxMUM5ZFRoZzBiZGsrZEFtRGN1SEU3MjdadDIvcllZNDlWaE1vQWszVVF5T2MyeHV2QWlOSUVOakRvOXc0RkFLSVlIZ2VDT0FtWHpOWVpMOC9CZkQ0bnJhczJiOTY4Nis2NzcyNVRwd0FZUDM2ODI2RkRCOVdzV1RPUFlaaXNUUU9ZdElHdUJhUVppQU5BTnN4UEFvU2tUTTRXQkNhMUh3VUFDUVF3bmUvaEhHUEZlVWxKaWRxd1lZTzY2NjY3YXNYRFdnUGdzY2NlY3krNTVCSjF5aW1ucUcrKytVYTk4TGM1cWwySHJxQ3EwdVhKRlNldUkyOW96ejJpbWU4bnZ1ZHEvU1hzdy9iTUZUZmp4cDV0LzN5K2JYOUtGWmFsMGxjQXJhUkhTdTB2MktCZXUvOTYxYng1YzdWejUwNDFkKzVjZGVlZGQrWVdBT2JrRjZqK0YxOWVyVkxUczVNRU0wM2NZM2E2VHZDNWxDNG4zQzd3UERPakRIZ2tDRjN6dXdPRDR2cHVvSTc5M0FuVmRnMzFnKzBjWTU4SEtsSnFVVUdsY21VTng0TkI5WnhJNnJjc21LR2V2K1U4SHdEejVzMVR2L3JWcjNJTUFNdTJxLzREdjZkcEFOZG5pb2xBQWMyUTVMa0JMRnpQWjZoakE0VzkvMUIvYm5SOVk1c2FQTU43UHQ5WnFmYVV1ZFVNY2Z4aCsrZHVLZzJBbTgvTkxRMEFIMkR3NE1IcTVKTlA5Z1kxSzMrSDZqZndzb3dHVUJFU3pvd1NGSWtpVWl3akRDbzZqbkVtOE9sMW82NlQxdFBmNWMrYnlzN2lsRnBWV09WelJHb0Eva2lsS3RYV2hlOFNBTTdKUFFCSURUQjcyVGVxNzBXWFZXc0Fnd1JsUTNnMzhqbXJkSGJndE9lKzFPdnFYTlJuNlFxTTB6Vzh5OUd1emFZcXFyNTV6aFQ2MGNsaVV2M2xLWTBaanFZQnFnZ0FpMmVxNTRiMlU4Y2NjNHhIYTVpQW5BR0Fyd0dXN1ZSOUxyelVzMTFHZFc1UXkweU1ETDhjQTdFdGR0azNDeGxWRXF1dXZUYU8wbXNMUldWb0syMjNHMmdRTWp0cHprbVFWZnRDV2p2NjNMaVhWUHYrak9PbmF3QStod2JZbGdhQTlBSHFIQURqeG8wTGFJQlp5M2Fwc3k0WW9xUUxtekVGQmlJcUMwQ1VzT215bmhWQTBlZUJ2aDJWeUw0SHhxN2RkQVZqby95TktGTlJXdW1xVDdkWFpxYWtjVjVlUWdOc1d6SlQvZTdHdmdFTlVPZGg0RzkvKzlzZ0FKWVhxak1IYUFDSU13Vko3TDh4U29obVRsUW9HZWxzbXNibW1NK2p3QlRYLzhwZGFjZFBjTUVHQW1pQWdpV3oxYk0vTzBzaDZiWmp4dzcxeVNlZjFEMEFIbjMwVVE4QWJkdTI5UVkxYThVZTFmdjh3ZjVNckpJV0ZSWnE5eHlrVXBVVFQxelVDOFRvVGt6L3dxeTRLaE81NkZKdGF4Tm42ME10TXVQWlhacFNYOER4TXpJL0RBUm9nSUtsczlXMEc4NzBBTUFhNE82Nzc2NWJBRHp5eUNNYUFQYXFNd0FBQy9HOWM1azlNOFhGYnBRZE44VGVrZW84WE44L00ybVV0QzloWm5qNEhkWTVXTnFoSmh5L3ozZVE0NWR4L0kyaEh3L0hveVUwd0tkejFOVHJ6MUF0V3JUd2FBMEFqQm8xcW00QjhQREREM3Rob0ErQWxVV3ExN2xDQS9EZnlCaS9XbXl6c2VseGRsWTZkR0ZuTEZPNVJuRzdzVjZtMDdpNlc0cXExRlp5L0J6QmRUUGpNK2RJQkJWODlwNTY1cnJUQXdDNDU1NTc2aFlBWThhTThRRFFybDA3dFgzN2RqVnoxWDRDd0NEbGU4RlJCSXdFaGVFOHFhTVZrMTh3dGRFakFPTzdOV2ZQNkF6S3prUTdubXM1aWYreUhaVitRc3NKaUw1ZEcwQURiUC9zZlE4QTdBTUFBTC8rOWEvckhnQXdBUXlBV2FzT3FKN25ERkpTOWNaSmJ1WTZhQ2Z0VHArdWFEVi9Jd0FRMS9BZWN6bzIwamV3Z0MvY2gwUkllSTVyZDFlcXZacmpsd1FJSGdBKy82ZDYraWM5UEEwQVdzTUp6Q2tBRkJRVXFKbXJTMVNQL2hjSHBTa2Rkd2ZVc2lTUEprbk1WQnREV0hxQ0FMSFVOekRCTnpWKzdnRE4zVURmQWFESzJEN1FVVEMyMTdXQkRvSzk1UGl0MjFNVklMb1BoSFQ5S0Eyd0kvOEQ5ZFExM1ZUTGxpMXpGd0R2QWdCOUJ5YVFzaHFZZ29pWTI2aDZJOTZqOTI5N3QxNG5hYnZndGFOU05LQlZ1NFRqRjlJQThqeXNEVHdOc093RDlYU3VBK0NkVlNXcTI5a0ROU2RRUlVpdUpkNjJTV01jc2JNSUw1WEtvbC9MczZUMXQ1UFRWM0FnRmV2c1pTNDBJRUFETFBzWGFZQ3VIZ0J5eGdkQUZEQm8wQ0FmQUROV2xhcXVmUzVTSVJ1b2hWWmhOVyt5cmJvcUR5YVhQS3hvT2YvZ21SUEJQTmY4YnMzZWg1TS9XcTRoZ1g5d01PV3FOU1Q5cWJRL29WUWM0K1U1K3pkVjZoc1BBRjE4QUVBRDFIa1VvQVBnN1JWbHFrdWZDNVZ1ayszZXRYMU5QYXArVkoveTJrMnJFZGhxaDY4MUxXVExIWVJHYjNVQU0zTXdSUkliOTFhcW9uSlIwMkR2dmRNSUlLaFVTbjJ6L0NNQ1FLZmNCc0NiQU1CWkZ3WUphMUhuWnVMSGgzdldjODNNZUxkcUdmTkhYZHVqaXd5UTl4OTAxUWJwK0FVY1BFZWNaL294YVFkUEF5ei9tSHlBSEFQQTJMRmozWXN2dnRnSHdQOFNBRHIzdmlEZ1ljZkYxdjU1QklIdDNyYzUzQXkzejZBcWtzSENtdzhsa0poaVVlQVMyZ1hIbDdzempwK2U4SEdDZnlMTmdrcFZxWjByUHM0OURhQUQ0STNsNWFwajd3R0JjSStYaHNQT1h0aHU2eXJWWjRUUnhvZFZkaURFRElia0d1QWNvOHF1YmhudlQ2allkbzRxTEVtcEhRZFMxaVhlYkxRQmRnVHRXalZYUGZVZkhYMEF6Sjgvdis1VHdUb0EvZzRBOURwZmpGd3l5WTJYMUFqMUh5dTVtZGVFNnhwTlFYQVBZR2dzeHZkRnJDMkljckRLVmV1L1RRWHVSenQ3d1VvQklMQUdJQUE4bmVzQWVIM1pRZFdoMTNrcVRtSmNWNFYyMXlZMkZUWW1HNjdqNnNoN3Vzcm4xSzVwTFlFVm1IY3VmWngwMWEzN3F0UStkdndDdXQybUFmVHpvRm53Tk1EcWVRU0FEcmtGQUt3R0RodzQwQWZBMzVaVnFQYW5uNnZranBpTWt5YmxKcHdxelRBaTI1RE9wTGFESVNQZkNsb1RQWkp3SXZvM3ZjK2M3aTJ1Y05YbW9tckRIN1RyZGlERW1RVTRnYnRXZjBJQWFPOERZTUdDQmJteEhDd0I4SmY4Q25WYXozT1ZFdFkxMG1zMnhOWTJKOUJSR3BQUzYvOVNBc05KSnAycGNhR21EWmcyTXhFT0diOG1yLzlnbFRKS3VIY2ErRkpLa0JzaGJaQ3VCQTJ3KzR2NTZxbXJUOHR0QUV6UHIxU25kdTl2endRYWlhaWRTODBSRXlsRW5VZjE3ZmVuOVczZDdXTUtZYldFRU03M2xLWFVydUpVaUpsY0pYT2VuVGFBQmloY3M1QTB3S201QlFEc0NMcm9vb3Q4QUx6MldhVnExNk8vc3UwS05qTEpOdzF5eHBtNmRuWHZtQmtjZUUrMDJZa2RXeFoxSzRudm00cXFncGxFcFN3MlBuMGRwdzNTNTU0R1dFc0F1RG9EZ0lVTEYrYkdsakFKZ0Q4UkFOcDI3NmN5dTRJZGc2U0YxYkJWQlh0dDNZd3pGbUtJcm9LckFTS0YweFkyUnZvUkFjZlBVYTZqUXUrUkYzaStxN2hLN1M5UE4weGs0d1VqSENleUxqVEE3cldMQ0FEdGNoc0FmL3lzU3AzU3RhL1d0ZU1SMTVZcURTVmZiSVJXRWFvL0lta1R5a0k2MVhrQUo1VFhqMUg1Rm44Q3BhelNWUVg3OVpnL0hOTFYxQ3dnRE55OUxrY0JBQjhBVzhJQWdGYy9yVkluQ3dCSTF5bmo5SVVKckROV2V0a0IvMEZqYXRDM2NJMGF3WFIrcUo4VlVOaFhrUklQTkNBa0MvMjRldGdzUUFOOHUyNHhBYUN0RDRCRml4YlYvZmNDSkFDd1J2M0tFZ0pBbDdPVkhnVkVlczVwTmUrZmh3aHQvcEpKT0l3TDF3K2xiWTN2eVFZMHd2OUlNM2xmZVVydEtSVnZOMHE0eFN3RWhUNERDazBiUUFOOCsrVVNBc0FwdVFVQWZDOEFKb0FCOERJQjRLVE9mWlNWYVNJejZJYllLYzZqa2o4eEN6eEJJTmo5Z1hCN0V4RHNZMFRCRGwrczlXT3BOOWtTYjdRMjBOdG1mcnVnU3UzNWNpa0I0T1RjQnNCTGl3a0FuZm9vTjJRQzdBeW95UmNyRXRYamNOSVVTbXIzalprLzZjMExQMFhXM1ZPYVVpVUhWU0ptWm9DUXZaTklZWURhc3o0SWdNV0xGOWY5MThOMUFMeTRxRXExNmRUSHAxRFF1YlBuenMxN0JqTWNDMzh6eHduZHovUnJrdDI0VEtMZVEzeFdFUG4rd3VLVVlKcGpaS0FWRkZrNGlmaUJpTDFmZmFxZXZ1cWszQWJBQ3d0VHFuWEhNOU1FTjJRRExZbVlhdlV1UmN5V0F3Z1AzM2NhdGI0ZElkR1o3NDQ2d1Eyb2ZocFJoYUlBZjB3Wlg3UTY2K2hVWDRINWxhbkFVQUlnQ0RCYnFScWJCUTREOTN6MW1Ycm02aHdEQUw0Y2V1R0ZGL29BK04yQ2xHclQ0Y3pNZmdDWjBSTk10RXFqVkxWOHJjSkFVTW9NRGxPb1dkdG5rbFRzdDVSV3VQNWlqMW1GTy9FYUlIQWViUmFRQ05xNzhYUDF6RlVuNWpZQW5sM2dxbGJ0ZXhzSmFFenpDcUpHcVd6NTNPNDhDci9ER0c0YUZuOTBoekprYXNSNXVzRGgyMTJTOGpXTGZIMllnUUlJRm84L2lUYUFCdEFCc0dUSkVqVnk1TWpjQXNDMCthNDY0YlF6bE1ubVZ2UGVzQWF2ZWZuaEwzaEdSQXVoYzN1eXh1NEQyUHdEYzhieXdFRlhsVmNHcVJqdDBDWFRCbEZPSWpSQTBkZjVCSUEydVEyQVp6NXgxZkZwQVBoRWkwejRSS3ZsZ01aUTRVcXVBSTdSVzFjeUJ5REdFMnJIVHFVYmVLY2ora083S2hML292Sk1aMGwzOTFaL1pHa1d0T1hnb3ErWEVRQmFld0RBdDROaEF1b2NBUGlGa0FzdXVNQUh3RlB6bERxK1hTOFYrcEVveVRkZlBUdVJXVDNCdy9SNWVCdFg4TnJjSnRoanNManBBYms2dHd4dGNMNi92TnJ4eXpBd0lSQnE2U1FpRVZTMGFUa0JvRlZ1QStCLzVqWlF4N1hyR2JDOThiRjhkV1dyRk9zK2cvdzVHQzFldC8xY1hQamRVV1pGR2w5K0o0VjlsYTduL0prWjZDVGM4dVhYemtvYklBemN0MmtGQWVBRUh3QXdBU05Hak1ndEFFejUyRkV0Mi9aVWdmMEEwZ1NFSkQxNWdzZFlWd2VJSWNUVUV6dlNKT2dPbzd6VU41L0E5Z2VxaGhpWW5Wa0lPWW5HUHBXZkN0NjNlV1h1QVFDL0V6aGd3QUFmQUU5OHBLb0JvRExMd1ViR3BWRVFWdi9oK2htbWhaTkNVZnNPQXU5U3dmN05Zd29YWHBUQ2FsOUZLazZxTTMvMEh5U1hYd0tOMGdhQnVrb0ZGb1AyYjE1RkFEZyt0d0V3K2FNR3F1WEozVFhiRzdUU1dxNGx4QVNmVWRJMkd5UTlLUFZpMzRGbVRyeHFqdkszanNsTW91ekMrNW9adjEyWUlZUjlwUlZSREZTSnRFRnR6QUpTd2Z1MnJGUlRjeDBBRS8vVlFMVWdBQVIvYnlmTmZJM29wZ2dnNk1aWmZtcE9hMmVYWHJOR2NKVDUvYVpuS0pEK3pHSlBoa00xQlVMOFBrQkQ3aUJGQU5pMlNrMjk4amdmQUV1WExsWERody9QTFFBOC9rR2VPdmJrYnNsamRXR0UrWXVlVEJEYkZ6WXp6cVZ0cFMrczVzTWdDWnNGazlaQTJGZFJwUkp2M0xBN2RMVnpFcjBmaTk2Mm1nRFFNcmNBTUdIQ0JQZjg4OC8zQWZEWUJ3M1VNU2QyQ3hMVndJUTQ1eTZZdjg5UTB2VVJvcUtYaWFXYWQxUndxN2xtVmpMdkQ0OFpDejQrc1VJTVBFemFJTkEyZlpNQWNHRGJHdlhNbFMxeUd3RGovNWxIQU9qcXgreGhqMThQdit4eHVqbVBFQTJzMmp3TGpxZjZaMXhUYnBSVVI1dUZLQ2ZSM0kreUFBaTByQWJBVkFHQVR6LzlWQTBiTml4M0FJRDA1S1B2NWFubUozWlJBZnN0dnhCaXlBM0l1dDR6OXZpbHBDdTlYVVIwb1pUaG1UM0I0MStMOThKZlNXbmhZVlNZbHZUSG5yelRtcGdGYUlDQ3RRU0FZM01MQUk4Ly9yaDczbm5uK1FCNDVMMkc2dWcyblgyaWhuNXJSMW1rTUNyNW8zdjh2c3AzckI2L0ZXamFqRzEraFB4ZG9DU0ptZ3pURG85WmdBOXdZUHRhTlMzWEFmQXdhWUNqVzNkV2ZsaW1na0FJbTRXZzNBYWN4RWdndU1HVXNqSkx0ZlRxYmMvMCs1THdzdjlrVWwxenN4RHBEeEFBaXJldkl3MXdqQStBeno3N1ROMXh4eDI1QllBeGN4cXFvMXAxVXF6V2RZWkxjMkRjNSs5THVLNnlvMUszd2FtRW1lcGFnT0NZVDYyTU1DelZIbVp0SURWQXlZNHZDUUROY3hzQS96MjdFUUdnby9MdHV1dGFnSkJobHZHWFBQbWhFbTJreUJxOGYxYytVR0VnS05tUDM0MWpaR2EwNURxSFJCdm9iU09CUUU1Z01RRmdXcTRCWU9MRWlSNEE4R3ZoQU1DRHN4cXBaZ1NBS0liemZaTjJrTnU0TXFCd2d2Ry9CZ1N2bmJqditva0V3eXl0aE05VU9weTdlMnZxSkhvYTRKdjFCSUNqZlFCOC92bm42dmJiYjg4dEFEd0FBQnpmUVFWMkJXc016OXpQYUFmZFdmU0JZQmt1ZjlOSVh3Q1N2LzJZZmZJbFEvMG9aZ1lUUHQrTmt3Z05VUExOVndTQW8zSWJBS05uTmxaTmoyK2ZBWUNGNFltMGd5aEJPNTVoVWtqTkc2WEtTUnh6Vno4M2F3TTdnQTYva3dndFY3cHpBd0dnV1c0RDRMNTNteEFBVGhNQUNEdDlVZVlnYzkvK2N6TFZqTmNJbUlEd3V0cU9sOEJEYXhZQ1k5TzBRVlRkNnZtU0J0aTVVVDByQUpDZm42OXV1KzIyM0FMQWY3M0RBTERuQUZ3M2h1RVc3UkMxZnk2UzJJRzJ0Y2pKYTlTeUwvRW1Od3VKblVUeUFVcDNiUXhvZ0p3QndMbm5udXYveTVoN1pwQUphSGxxSUs2MzVRQXlHc0UxbXdQYm9MT3hxM3FrNTJRcUp0Y0dqcFdaNW42QzlRK050aUVUVVBpMW1uWkZVdzhBK0tkUk9XRUM4T1ZRdVJwNDExLzNxYnlteDZhSHJBS2NkSTJTN1liV0Myb3lBOXMvWDRqMjFNTXFXMW5hT2xvbDZ4YnZ3QmgwbFdGNFZReFEvUHRFb01xeWZlclo2MDlTSjV4d2dxZHRrUW1zOCs4Ry91WTN2M0h4WDZ3YU5XcmsvNU5tK1MvZ1RmOFZuTytiL21HMC9seis4K2hxZ21VK3Mva0gwcVo3NkZmdnkxUk0vMVU4MjdyeUgwTHIvMEplLy9meFVmOWNtdnZDUDVMR2Z4QWZQWHAwM1FKZzFLaFJMdjZQSFFQQXh2ZzRZTVMxaldOOEZEakt5OHRWY1hHeEp6bUZoWVhxK09PUDkvNzdOdjlIODRxS0NrK3RidHUyemZ2L2g3dDM3MVpISFhXVU92cm9vN09pUlJSUWt2ejdlTlBCd05BL0FZQjkrL1pCQTljdEFJWU5HK2FDVUEwYk5nd3gwY1IwRzZQajJzWXhPZXBlYVdtcEI0QTJiZHA0dGhNQUFDaWd1WEFma29SZk9ObThlYk5ueWc0Y09PQ0JvbFdyVnJHTVRWcHN6STI3Snhrdjd3TUFHT2ZreVpQckZnQS8vL25QWFVnTEE4REdTTk96cU9jNDJBUmt3MnpicDhrVTJLNzFjaWhNZ0dTZzZWeG50UDZwMTBkZEFHRHExS2wxQjREcDA2YzNhOXk0Y1FuMkF6UnIxaXhBZEVuYzJFRWtiR082SDlXL0RvUWtiWkl3VzYrVEZDQlI0TWltRGU2VmxaVjVPNElJREVmOStNYy9MazAwQUJPTmF0b1FaYzZjT2ROSXJRNlR6bHhTU1ROSnNMd2YxUzdxUG1zUnZTK1RvMmdqcnVsZVlFc1pKN2UwVDFrM20vcHhmWm1lc3hrZ24rYlpnUU1IRHE4cEQyc0VnQWtUSmpoa1AvUGF0MisvZzlUL0NWTDl4eEc5dHZlVDFJMHpQVkVBc0JIZmRGM1g5ZUNua0EremUrdldyU2ZSWnhYOHNjTU9nTHZ1dXF2Qi92MzdHeFlVRlBRWk9YTGtJdGgvU1doSmNOZ29hQWN1cTFhdDhwd3NNaHZlTmY3OTJkNjllMzJHVUwvZU9ad3pMdkRXb2U3Z3VER1RjUTMwczVmT1hqdWJJUlE0ZHdjUEhsVEhIWGVjM3c3M1VJL2ZoM1o0RjQ4SGhjZmN0R2xUL3g2Y1JFUTZQQmUweDFoUkIrQkgrZmJiYjcyK1pUczRuMkFVN25PUlk4VjdVUi9lUEFvWWlnUDN1ZDhOR3phb004ODgwNHRTZENCQUMyQzhUejc1NUhtZE9uWEtKNmUxOHFHSEhwSy9WWFpvQWZDREgvekFhZEtrU2NNMzNuamphSEwrN3J2dXV1c2V3QVJNRW9sSmdXazhFUlFraWpwMjdPaUJnME1aNmk5QUhCQmF2eWVaQytZendCQjZjcjhJMzJUUjI0RmdBSk1NN1pCTUFRZ2xjQkFtQWpRU3VIci96Q2pKV1BSMTRva25Ca3dVUU1IQWxmVk9PdWtrL3hyUkNHaUU5NEVtZS9iczhhTVBuc2U2ZGV0VXYzNzlqSm9Cb1A3em4vODg0Zm5ubjU5MHl5MjNGQk5OS2w5ODhjWEVtaUFyQUpDejBZQWNqNlpFa0ZZdnZQRENPeFE2blFHMG1nQUE1b0NZYkk5UndBQUFCcEloZ1FGQ1FoTklTUVJCTURrcFVheHBJSDJTK0N4RkhOZnp1OEJjdkl1QmdnTFFRWEk0YjRHQ2N4QWZoMlFnNm5JMHdnVjF3VmdwL1NnWUU2U1VrelcyT2FCZ1hLekZBQUNXZUx3TDRFTktYWm9uaEs1SXQrdk1SMEUvbXpadFdqbDA2TkFmbm5iYWFZV1hYWFpaMlVzdnZaUllDMlFGZ0N1dnZMTGhtMisrMlp3Y3YxN1RwazM3Q0g2QUhxcEptd3ppdDI3ZDJtK1BpY2xrakNRVVZKbVVSQkFhSnFOTGx5NCtpUEFKeVZ1N2RxMDYvZlRUL2JvZzNwZGZmdWtSbHZ0bHhzTU1TTENBUVpBb1NDdlh4ZnNCR0FZekZ3QUZFaWpuZ0xvQUsrcWpEeTY0QjBaTFpqTllBVTZzbGNpNVlYd3dMVGlnRWFENWVJNm9EMDJBOXlNL3NYejVjdFcvZjMrdlA1TWZRSDFVL2VJWHZ4aEUybVhWcmJmZWVvQUFJSCsrNHRBQTRPeXp6M2FJU1kySTBNZDkvL3ZmdjUzS0kxQ25KdVpqWUVBeVZKblVBQ0E4T1k2QmU1Z2tVQ3laaEFMQ0F5eXlRSnJRRm95U1VtbFN0U2EvZ0VFb0djZGd3YmgxU1VWZGdFcmVoOFNDUVpCMnFWazJidHlvT25Ub0VBQVE2QUNWcjVzbmpCZTB3YndCVUpnOE5uc1lDMmdpeDQydFgzZ1grdEhOQU9jRG5uNzY2WWZmZnZ2dDU4NDY2Nnc5QktpSzJiTm5KeklEaVFFd1lNQ0FCc1RBcGtUWU51Um92RWlJSEdLei81Z2cvc0V4R0lDQmM4Z0N0Sjk2NnFrK0FEQjQ2ZEJCa3JrdU14WDNVQi8zSUUwNDErdENXZ0E0cmd1cGdFU0NxQ0NrSEFPMEQ0REZkcGN6YW1qSENhMm91bUFReGd3QXNBbkErd0FXWkJwUkQrOURYWjRIK21DdzRCNVVPcitMTlNnbmQxZ1lRRDh1bU11eVpjdlVPZWVjRTJBK080SVkwOEtGQy8vNTRJTVAvaWN4ZnllWmk3SzMzbm9ya1JsSURJQkxMcm1rNFljZmZuZzBEYmdEcVpoNU5Lbm1iTE5Oc1Rla0ZZekJwQ0J4VXVweERaV05DYkRxQTFNeFVZQ0VuU0FRQWhJSGdrbHRnRGE3ZHUzeWlNa1JBOXFER1BpOVl2YjhVZkFjZGZFdWxpcTBCOU1oeVRqbnNhRWRKRlk2b1hnTzRHRXVZSXEwKzNnZnhzemFoeG1LZTdvNXcvc3hYbVlneGdXQTZRWEFBcUJnWWpBdVhtakRyNEhnMy9QcFBnREdBQnJSSEEvY2NNTU5GeEc5djc3MjJtdUxYMy85OVVSbUlCRUFldlRvNFJBeUczMzk5ZGN0enovLy9Hc3BGSndLWXNpd1NBSUF6SWZOd3lSQUZHWXlGMHdRakVKN1ZvOWdDTkFQNHNIdWMwRmZYMzMxbFJjS3lYczRBQzZwWG5XR2NGMUlpUFRzUVR3QURkNTk5KzdkL2JGREhXTWN1amxCWFVneWdNdW1DdGRzanFUNXd2dlJEN1FCRjh3TFlKUDNNQWFZS1Zud2JnQUE5R0xhOFZobXpacmxPWUlNSmdZQU82OFk0NlJKazBiTW16ZnZkZktQOXBMQVZNeWRPemZXRENRQ1FKOCtmUnFRcDltVXBLRDFUVGZkTk9GSFAvclJEVkp5SkFEWXkyWjFwUmVldUpSU2xDMWJ0bmptUVJaV29aSndLS2F3RDFJQXdzc2NBZ29XZU1nN0RnRVFLaHNPbGl3bXZ3TjlRb01nZnlFTENZTTNYdW1Mb0NCdWg1OGo3MFBTQVJJSkZBQVQya1pxUm81dUFEUUpXTkRoL2ZmZjk4Q0dkMHJwNS9VQmdPY2YvL2pIYXhRQ1BrRDAya1crUU5sNzc3MFhhd1lTQVlDa3ZpSFpHQVRRcDAyWk1tVW1EYUl0Vkp3cC9ZcEpBYlc4bnM5Mm1lTitITkFlYU0rTEgyQUlKZ0RtUWYyeXV1UjRHL1VaOWJnUDRxRXVxMk1PcDFBQVRDWktPbE1XVU4yb0M2Wnl2eElVMEJUb1Y0SVpkYVdwNGJwZ0Z0NkZlYkQ5NW5rZ2F1Q1Frc2NMRThWK0FOdDYxSWVtWkliaVhYZ0dnRE1kdUtBdHdFV005Wmt2elFIR1RrSzY3YmJiYnZ0MzRKNkV0SGpHakJteFppQVdBQjA3ZG5Sb29JMjJidDNha2lUcDRyRmp4LzZWME9rd1kzVUFZRTI5WjgrZWF2MzY5VDVCZGNrR2tqSFpMNzc0UW5YdTNObS9EN1dIQWlLeTFLTmZUSkRlNzNuazBweEFZa0VZWmlTdk1LNVpzMFoxNnRRcHBQSkJkRTdDNEJtYkRQUXJDUTJmQTg5WUczQ1NCbldob3JuZ0hoakZ0cDBMbkdQUUFkcXJhOWV1L2ozTUdjQ1J5U2lNQi9SQVhRQUNnSUxHd0pneERoU2VDNklCaXNaQ3pHZkJJSHE0OTkxMzMzV2tuVDd1MXEzYlhxSkx4ZEtsU3lQTlFDd0FpSmtOeUY0M0pRSzJ1dlRTUys4bkV6QWNCR05pNndBQWV1R3NSQlVBZytObVNReVlBVTU1U3VrRWNVQThPSWNzeVp3NDBzTkhFSmdCeEFCZ0ZZeHh5c3dnSjZxazJ1ZFVNSmpMWU9PNktESW5BRkJoREhxb2lmdVlJeHhIQ0FNS21BdkdTUWVUYWNlZ3F2NWlqT09CWGMrSW9uejAwVWVleHNCY2RBQXdtRjk0NFlWcE0yZk9uRWkwS2lUZnJZeDhna2d6RUFzQXN2OE44L1B6d2FWVEgzamdnVCtkY2NZWlozTDhyd01nN1kxNkRodWJBQTV6ZUxzVFBpSHBNQk1ncGd5bElMbUVYRC9PWjdVS2dzQ095MUFLdGgzRTBPdENhdUFmeUg0Um84TXVvNzJzQ3pzTzZaTDlRbklobFVucXdwRUZVTmtjWVg2b1M2cllmeCtIc0dBT25uTm95NkVtM2dkQjRJZ0tRQWVBMEJiOVNvY1BkZUZNeW55QTFBWUFMNFdMeXlsTXZ4SHlSQUpiVEw1RHBCbUlCQUE1UGc0Um9CSFo5UmFFdWo0VEowNThoeVNyRVdmTWRBREFzWUt6QkNMb2hXMGxQMlAvZ2VOZTJFa3BTU0FVR0E4cFlFbG1JdkVpRGhkSUVKZ0JRdktZUUdSVy9TekplQ2NZQmo4Rno1bVpBRFJBeVhaZDFrVjdXVGozQVFtWEJWcVJuVHFXWE13SDh3Q3dNVjR3Vnkrb0wwTkxGTHdYQUVkYnZBZjk0YjJnQXdET2lTeTVhUVFGQWtoanFCZ3hZc1FQYVQ3NUJOZ2ltbHZGaWhVcnJHWWdFZ0RVUVFPUzZLWkVtRllVZ3R4eDY2MjNQb0JCeWMyYUVnQ3crL2pOUU4welJ1RXdUL2YrNGRod09DalhBakFwWkE3aEkwZ0hEa3hDa2YyZ0x2cVIvZ1RlaFhlQ2dmSStKQnJTRENLek91ZmtGZnJBb2dzWGxuSVpSZUJkbkEyVTBRazdvbUFXajVkQkRzYkxyR0ZjQVMyUkorRndHSDF5ZTJKbUNBQjhqcmxCQTArZE9uWEMvUG56ZjBlOEtxUzVseTFac3NScUJpSUJRUEZrdzlXclYwUDl0eHM2ZE9oVGd3Y1AvamNRVHE2dDgwUnh3S203NnFxcmpKc3BvUlpoYTNXYi9mSEhIeVBLQ0RBZlJWODFRd0dUSUtGNlhkaG51WUxHN1dVR2pndlVxQjdTUVQyalgxMFNUWFY1eVZyUGJaanFjclNnNXhYaUNwaEp0bHVSdWZWQXlyRS8ra05Ha0tNU214OHdaODZjRHlnY3ZKTzYyanB3NE1EaXVYUG5XczJBRlFDRWJvYzZiVVNJZ290OCtyaHg0OTRrU1dqQjRaOE9BS0FmS2h2eFA5dFBHZjVCWW9CY0RnMXhEODh3b2Q2OWUzdHRjSi9yZzNCeXV6bjN3ZWxsOXVMNVBsUXdyNmh4S2hoQVpCTVNsV0tHbGtDLzdFK3dxWUlUcDllRnFjSTdPSlhMak1FWU9OemtlWE5Hai9kTXlNMG92S3l0Ny8vanFBY21BQnBNcmk1eVBaZzhEaC8xQSs4am42ZG8xS2hSVjFLVDFlU0xGQkVOS2tpYnVsa0JnRUkzaHlic0xmMlNHcmwrNU1pUms2SHk5UDMvREFBUUZpOUhaZzIrQUNZdnd6OEFaK1hLbFFGbkRnU0hxaU52TldSVE1Va3dVUmJVeHp0QnZMb3E3S2NrR1M4dkl1bmpCVk9oRVptcDhyTlhyMTUrVGdOMGdzclhWd0FCS0RZUGVrZ0lrQ0lTbXpScDByM0U5TCtRR1M4a1FTb2pRY3NPQVBTQ1BMTHBudm9mTW1USXVLdXBRS1hxMjZ3WUFGQ0JrRGdzVzJMQ2tBU3Bxam5rZ3UxbUtRQWhFTnYyN2RzMzVEZXc1TWlDZmxuNjY2ckFudk4rQjFrZ3JicFpBSE5RMzdUS0tBRWdHUXdOeWc0dTJuLzQ0WWNlVS9WNm5NTFdBWUJyMEhyNjlPbHZ2UHZ1dS85TlZiZVMvMWE4ZVBIaUt0TjhqQUFndGVmUVpCcVNHa0tBMnBQVXlaOG9ubTNINlY5OW54MWVqQW5Ca2J2c3NzdU1oTU1hUGdZdEM5UThZbHUwMFdOZURxVjB3a0hWYzkwa080NFBWV0hDUTlNQmdESWhoQUxIRXN2QnNyQXBrcmtERkRpM2NEalJKMGNWL0E2WnRjUjlSRHpzNk9HYXY3UEFld2hrRk1BQUFGMlhMMSsrZGZ6NDhRZ0gxNUF2c1pmYVZkSVliZCttRHhheTFiRC9UU25rYUVWby9ON28wYU9mSTV2VEFJVFg5LzJ4L1VkNGdzbXdMWmNyWUd6SGVCc1hmeHVIY3dQc0Y4ajRtTzl6TE0zMWRjYnIyc2oySFFONWJ0cGFwUittNXhJTVBGNmNROG94WHRZTVBEK2VCOU9EZlF1K2g3YndNV1RTQy9Wa0dDM0hpd0xubHAxaGFHVFQyS0VweVI5TFBmVFFRN2VUZnpPYkJLbVFURmNaT2VuSkFFQjJPbytrSCtxL0xZVkZvMy82MDUvZURQdXY3LzVsb25QT1Bzbk80S1NIYWFOcDBuWnhYMG5UTjIyWUpGMmVKd1ZJSEtCa3lNWUh3SUxrRnhkMmZybm9DMVRRSEd4T1RSbEI2UWU4OHNvcmYxaTRjT0hqMUd4Ym56NTlpdlB6ODBObXdBZ0FVdVdOcUFONC96MkorYzhPR0RDZ0YyeTN6aFE5RDFCVFJzYlYwYjhpRnRVMkNnRHlNREUvanVtMUJZSHA0SnlDN01zMERqNEhZT0NJUnZVSm9FRkxVSWk5NnZlLy8vMHdtQUV5djBWa2hrTVp1aEFBQ0cyZStxY09XaEdoTHI3MzNudGY2dGl4WXhQT3BSOHFBQ1JodXVsYS82WXdydkd6NlFqbCtCbUhvSHpvMTdZdm5NcHJXK0Zua0ZKNDRyVUZnTTY0YklGbWE1UGVSMUUrWnN5WVc2bk94MjNidGkwa0UxNUdHaVNBK3RCTVNmcnpTUG85OVU4VEhERjA2TkFSV0RlWDRkK2hZSFMyOTIyYlR4RXQ0SHZ5eUVEcWpKUU1TOHBjazFZd2FRbHNVb0hxNW1YYnc4WDhtcmFEU1VZdTRmbm5uNTlLdG44cXpBQTU4c1ZyMXF3Sm1JRVFOY2hqNWVSUGo4R0RCMCs2L1BMTEI4RCsyeHlxN3dvQU5qT0FWQzJ5Z0lpZmRiVnVzK2UxZWM3bmVDL1VONXk0dW1KK1ZGdmNoOFA0OXR0dkw1ZzVjK1o5Tk93dnNEWkFHaUJnQmdJQW9CQUwxMWo2aGRkeDBlMjMzLzVzang0OVdpTDBpbU5TWFFFQUN5MzRoUktBNEx0aVBnckNNVWdZdEdNdUFnQUhRdENWSzFmdWZlS0pKK0FIektQUWNUZHA4ckl0VzdiSVg4UU5TSDhlU1QvVS95bmtDOXo4eTEvK2NqUkZCSTYrK3plWEFBRDFmKzIxMTFvOSs4UEJmQ1l3c25SWUlzNVZBRUJEd2VaUG1UTGxjZUxySDJqb0JXVFdpOWV2WCsrYmdRQUFTSjAxSXVjUFFXbjN2bjM3UG5MRkZWZGNpZ1VPM2Y3bUVnREFCQnBuclJsYWs3cjQ0a3FIRGgxeUZnREltMkNUemZUcDA5OWZ0R2pSd3pUa3RTVFErMGh6K1diQUIwRHo1czJKbmc2V2ZxSCtMN2orK3V1ZjdOZXZYMXZlMzVlTEFNRGtrWUViTW1USWR5YjU4aDZXdjVIOVpPY3gxd0NBQTh2REN4Y3UzUGJ5eXkvZlE4T2VULzdjYnFKakdma0gvczhzZTRYaS9MdzllL1lnK1g1SzQ4YU5meko4K1BDeG5UdDN6ck9GZjdrQUFOZzQzTU1PcE85Uzh2a2NUaFp2Q2N0VkFDQWNYTGR1WGRYRWlSUEhIang0OEc4d0ErM2J0eS9adEdsVFZRQUFGTmMySXVtSCt1L1d2WHYzMGRkY2M4MFZ2SEtYcXdDQWVrUG1qTDljeVYvTTRFLzl3RnpnenlCMFF4dGUwRUhJaEhRdVVxaFk1ZVBkdVh6d2JtWk9hL001eG9ETkpraVM1U29BZUV2Y3E2KysraGFaTEdRRjE1RXp1QTg3aDN3QUVHR3h5N2NKVFJ6cWY4Q2xsMTQ2ZnRDZ1FkMnc0SkNVMlhVQmdOV3JWM3VUWk9iTGRRalRKNmRpR1RDOHFzaE1sVnUyT0wzTk9YMTV6UWY2QXdCQXAxd0ZBSjRqTFR4Nzl1eDFNMmJNZUpDbXRvQ0VmVGZOdWJ5a3BNUmxBRFRBYjgzUUtiNXRjVFY1LzJNcC9HdW1oMys1QmdCc0p1RTlkY3hrMHprdjBDRGxpaFFwYjlyZ1RLYjg1UzJzOG1GeFJtYzhuK3VmV0xIRWthc0F3SkVPQjBzcEdoaEwwMzJEanUxazJvbi9KU2tHUUI1MWhNWHNqblRjZlAvOTk0OGdaRGZtN1Y5eEsyeHh2L2FWTFdEU1l6SStsMjJ4eEF3N2JGTDN6R1JPQXpNQXNNdEgzOUltaVFsMUR1Q3pGNjMvc0tNMERXaVBiQ0NXZTAyRWwzM1hsdEY2UHd6Y3FMNTU3SmczMGVyZ21ERmprQkZFT0xpUkFIQ0FBRkFsQWVCdC9hYmpodjc5K3c4bFA2QTlJZ0JiQ3BpWjVOa1I3YjZOY1hIMWJHMU5nSkIxNVZqaVFDbS9pbVVxdXJPbk0xTy9iN29ucitQcVI3Vk44djY0K2pCcldGRWtEYkJwL3Z6NWY2VGJyOUd4aFFCUTdBT0FwQU5VYVVLb2hnOXdIbDFmMDZWTGw0dklWcHhDd01pVFNSWkpmTk9uWHM5V0orcGViZHFZd0dHNmw2U1lJZ0FUU0tMcUpMbWZiZHNrL2ZBNUFiNnFxS2lvZ0RUQVBESmJmNmRiaTBpb2tSRXNseVlBdi8yVFJ4NHcvQUJzcisxTkIvWkhZOTl6Y0t0T2Zmbi9WckRCRU44eCs1U09GWFFVa21rdkljMVFSVkZQNXQ4bmtXZnM0UGRlNkVGVDBnUUFBbndDZk1KVi91NzJYdFdYUTFtZ0JoRHY0MHVYQjhndktxRXd1SXkwUTFWeGNYRXdFWVJDYWdFZ2NLRDJjU2hQYTNyRk84bm16VmxXUDJ4OUhjcHg2RVZYMGJuVXAxdGQrTk1sNWxmQkhGQnh5OHZMell0QnNqRGp4ZVVobjJ4VSthN2ZsNnVsTm9Cd1JXTVM2T3kyaGRlWEk2UFVBK0FJTC9VQU9NSkxQUUNPOFBKL1Zqd2JyRUNLdWtrQUFBQUFTVVZPUks1Q1lJST0iIHBvaW50ZXItZXZlbnRzPSJub25lIi8+PGltYWdlIHg9Ii0wLjUiIHk9IjE0OS41IiB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgeGxpbms6aHJlZj0iZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCcFpEMGlUR0Y1WlhKZk1TSWdaR0YwWVMxdVlXMWxQU0pNWVhsbGNpQXhJaUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXhNamdpSUdobGFXZG9kRDBpTVRJNElpQjJhV1YzUW05NFBTSXdJREFnTVRJNElERXlPQ0krSmlONFlUc2dJRHgwYVhSc1pUNURiRzkxWkNCTllXTm9hVzVsSUV4bFlYSnVhVzVuUEM5MGFYUnNaVDRtSTNoaE95QWdQR2MrSmlONFlUc2dJQ0FnUEhCaGRHZ2daRDBpVFRFeU5pNDBOeXcxT0M0eE1td3RNall1TXkwME5TNDNORUV4TVM0MU5pd3hNUzQxTml3d0xEQXNNQ3c1TUM0ek1TdzJMalZJTXpjdU4yRXhNUzQxTlN3eE1TNDFOU3d3TERBc01DMDVMamcyTERVdU9EaE1NUzQxTXl3MU9HRXhNUzQwT0N3eE1TNDBPQ3d3TERBc01Dd3dMREV4TGpRMGJESTJMak1zTkRaaE1URXVOemNzTVRFdU56Y3NNQ3d3TERBc09TNDROaXcyTGpBNVNEa3dMak5oTVRFdU56TXNNVEV1TnpNc01Dd3dMREFzT1M0NE55MDJMakEyYkRJMkxqTXRORFV1TnpSQk1URXVOek1zTVRFdU56TXNNQ3d3TERBc01USTJMalEzTERVNExqRXlXaUlnYzNSNWJHVTlJbVpwYkd3NklDTTBNamcxWmpRaUx6NG1JM2hoT3lBZ0lDQThjR0YwYUNCa1BTSk5PREF1TVRnc016VXNOamdzTkRGc0xUWXROa3cwTUM0NE5pdzBOMncwTGpZMExEUXVOalJNTXpNdU9TdzJPU3cwTVN3M05pNHdOaXcwTnk0NE1pdzVNMnd5T0M0MUxESTRMalZvTVRSaE1URXVOek1zTVRFdU56TXNNQ3d3TERBc09TNDROeTAyTGpBMmJESXlMakEzTFRNNExqTTRXaUlnYzNSNWJHVTlJbTl3WVdOcGRIazZJREF1TURjd01EQXdNREF3TWprNE1ESXpPMmx6YjJ4aGRHbHZiam9nYVhOdmJHRjBaU0l2UGlZamVHRTdJQ0FnSUR4d2IyeDVaMjl1SUhCdmFXNTBjejBpTnprdU9UTWdOelFnT0RJdU9EVWdOamtnT1RRdU1TQTJPU0E1TnlBMk5DQTRPUzQwTmlBMU1TQTNOeTQzTXlBMU1TQTNOQzR6TXlBME5TQTNNU0EwTlNBM01TQTBNU0EzTmk0Mk55QTBNU0E0TUM0d05pQTBOeUE0Tnk0eE5DQTBOeUE0TUM0eE9DQXpOU0EyTmlBek5TQTJOaUExTWlBM01pNHdNaUExTWlBM05DNHpOU0ExTmlBMk5pQTFOaUEyTmlBMk5DQTNNeTQySURZMElEYzNMakEySURVNElEZzJMak00SURVNElEZzRMalk1SURZeUlEYzVMak0zSURZeUlEYzFMamtnTmpnZ05qWWdOamdnTmpZZ09ETWdOemd1TkRrZ09ETWdOell1TVRnZ09EY2dOallnT0RjZ05qWWdPVE1nT0RBdU1UZ2dPVE1nT1RFdU56Z2dOek1nT0RVdU1UVWdOek1nT0RJdU1qSWdOemdnTnpFZ056Z2dOekVnTnpRZ056a3VPVE1nTnpRaUlITjBlV3hsUFNKbWFXeHNPaUFqWm1abUlpOCtKaU40WVRzZ0lDQWdQSEJ2YkhsbmIyNGdjRzlwYm5SelBTSTBPQzR3TnlBM05DQTBOUzR4TlNBMk9TQXpNeTQ1SURZNUlETXhJRFkwSURNNExqVTBJRFV4SURVd0xqSTNJRFV4SURVekxqWTNJRFExSURVM0lEUTFJRFUzSURReElEVXhMak16SURReElEUTNMamswSURRM0lEUXdMamcySURRM0lEUTNMamd5SURNMUlEWXlJRE0xSURZeUlEVXlJRFUxTGprNElEVXlJRFV6TGpZMUlEVTJJRFl5SURVMklEWXlJRFkwSURVMExqUWdOalFnTlRBdU9UUWdOVGdnTkRFdU5qSWdOVGdnTXprdU15QTJNaUEwT0M0Mk15QTJNaUExTWk0eElEWTRJRFl5SURZNElEWXlJRGd6SURRNUxqVXhJRGd6SURVeExqZ3lJRGczSURZeUlEZzNJRFl5SURreklEUTNMamd5SURreklETTJMakl5SURjeklEUXlMamcxSURjeklEUTFMamM0SURjNElEVTNJRGM0SURVM0lEYzBJRFE0TGpBM0lEYzBJaUJ6ZEhsc1pUMGlabWxzYkRvZ0kyWm1aaUl2UGlZamVHRTdJQ0E4TDJjK0ppTjRZVHM4TDNOMlp6ND0iIHBvaW50ZXItZXZlbnRzPSJub25lIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAzLjUsMjAuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3Qgc3R5bGU9Im92ZXJmbG93OnZpc2libGU7IiBwb2ludGVyLWV2ZW50cz0iYWxsIiB3aWR0aD0iMjc1IiBoZWlnaHQ9Ijg4IiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMTJweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigwLCAwLCAwKTsgbGluZS1oZWlnaHQ6IDEuMjsgdmVydGljYWwtYWxpZ246IHRvcDsgd2lkdGg6IDI3NnB4OyB3aGl0ZS1zcGFjZTogbm93cmFwOyBvdmVyZmxvdy13cmFwOiBub3JtYWw7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOmluaGVyaXQ7Ij48ZGl2IHN0eWxlPSJmb250LXNpemU6IDE2cHgiIGFsaWduPSJsZWZ0Ij48Yj48Zm9udCBzdHlsZT0iZm9udC1zaXplOiAxNnB4Ij5UcmFpbiBvbiB5b3VyIGxhcHRvcCBleGVjdXRpbmcgPGJyIC8+PC9mb250PjwvYj48L2Rpdj48ZGl2IHN0eWxlPSJmb250LXNpemU6IDE2cHgiIGFsaWduPSJsZWZ0Ij48dWw+PGxpPjxiPjxmb250IHN0eWxlPSJmb250LXNpemU6IDE2cHgiPsKgcHl0aG9uIHNjcmlwdDwvZm9udD48L2I+PC9saT48bGk+PGI+PGZvbnQgc3R5bGU9ImZvbnQtc2l6ZTogMTZweCI+wqBnY2xvdWQgbWwtZW5naW5lIGxvY2FsPC9mb250PjwvYj48L2xpPjwvdWw+PC9kaXY+PC9kaXY+PC9kaXY+PC9mb3JlaWduT2JqZWN0Pjx0ZXh0IHg9IjEzOCIgeT0iNTAiIGZpbGw9IiMwMDAwMDAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTJweCIgZm9udC1mYW1pbHk9IkhlbHZldGljYSI+W05vdCBzdXBwb3J0ZWQgYnkgdmlld2VyXTwvdGV4dD48L3N3aXRjaD48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjI2LjUsMTc0LjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlOyIgcG9pbnRlci1ldmVudHM9ImFsbCIgd2lkdGg9IjI2MiIgaGVpZ2h0PSI4MCIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDEycHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMCwgMCwgMCk7IGxpbmUtaGVpZ2h0OiAxLjI7IHZlcnRpY2FsLWFsaWduOiB0b3A7IHdoaXRlLXNwYWNlOiBub3dyYXA7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTppbmxpbmUtYmxvY2s7dGV4dC1hbGlnbjppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0OyI+PGRpdj48Yj48Zm9udCBzdHlsZT0iZm9udC1zaXplOiAxNnB4Ij5UcmFpbiB1c2luZyBDb21wdXRlIGVuZ2luZXMgPGJyIC8+PC9mb250PjwvYj48L2Rpdj48ZGl2PjxiPjxmb250IHN0eWxlPSJmb250LXNpemU6IDE2cHgiPmV4ZWN1dGluZzwvZm9udD48L2I+PC9kaXY+PGRpdj48dWw+PGxpPjxiPjxmb250IHN0eWxlPSJmb250LXNpemU6IDE2cHgiPmdjbG91ZCBtbC1lbmdpbmU8L2ZvbnQ+PC9iPjwvbGk+PC91bD48L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iMTMxIiB5PSI0NiIgZmlsbD0iIzAwMDAwMCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxMnB4IiBmb250LWZhbWlseT0iSGVsdmV0aWNhIj5bTm90IHN1cHBvcnRlZCBieSB2aWV3ZXJdPC90ZXh0Pjwvc3dpdGNoPjwvZz48L2c+PC9zdmc+"
     ]
    }
   },
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "![gcp_training_options.svg](attachment:gcp_training_options.svg)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### Modeling and ML-Engine"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "![gcp_training_options-overview.png](Images/gcp_training_options-overview.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "- Environment Variables with absolut paths to relevant folders: \n",
    "    - `PWD`: where your project folder lies\n",
    "    - `PKG_NAME`: Self-Contained Package to be exported into `site-packages` in `venv`\n",
    "    - `trained`: Where to store checkpoints (logs, weights, graph)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "center",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "echo \"Working Directory:     $PWD\"\n",
    "echo \"Local data Directory:  $PWD/data\"\n",
    "echo \"Package Directory:     $PWD/src/$PKG_NAME\"\n",
    "echo \"Saved Model Directory: $PWD/src/$PKG_NAME/trained/\"\n",
    "rm -rf $PWD/src/$PKG_NAME/trained/ # start fresh\n",
    "echo \"Erased previously saved models\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## 1. Running the Python `module` without gcp ml-engine\n",
    "\n",
    "- Entry point is defined in `task.py`\n",
    "  - parses command line arguments \n",
    "- conda env has to be active"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "code_folding": [],
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "source activate gcp_dl\n",
    "rm -rf $PKG_NAME.tar.gz ${PWD}/$PKG_NAME/trained\n",
    "export PYTHONPATH=${PYTHONPATH}:${PWD}/../  \n",
    "echo \"Python Package Path: src.${PKG_NAME}.task\" "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "center",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "source activate gcp_dl\n",
    "python -m src.${PKG_NAME}.task \\\n",
    "   --data_path=\"${PWD}/data\" \\\n",
    "   --output_dir=${PWD}/src/${PKG_NAME}/trained \\\n",
    "   --train_steps=1000 \\\n",
    "   --job_dir=tmp\n",
    "echo \"Saved model: ${PWD}/src/${PKG_NAME}/trained/export/exporter/ \""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "#### Saved Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "DATE=$(ls $PWD/src/$PKG_NAME/trained/export/exporter/ |tail -1)\n",
    "echo \"Date as integer: $DATE\"\n",
    "echo \n",
    "date -d @${DATE} "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "#### And we would be ready to deploy\n",
    "\n",
    "... but of course not without looking at performance metrics or predictions!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true,
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "ls $PWD/src/$PKG_NAME/trained/export/exporter/"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## 2. Training using `gcloud ml-engine local train`\n",
    "\n",
    "- continue training using `ml-engine local`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "source activate gcp_dl\n",
    "gcloud ml-engine local train \\\n",
    "   --module-name=${PKG_NAME}.task \\\n",
    "   --package-path=${PWD}/src/${PKG_NAME} \\\n",
    "   -- \\\n",
    "   --data_path=\"${PWD}/data\" \\\n",
    "   --output_dir=${PWD}/src/${PKG_NAME}/trained \\\n",
    "   --train_steps=3000 \\\n",
    "   --job_dir=./tmp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "!gcloud ml-engine local train  --help"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## 3. Training Cloud using `gcloud ml-engine train`\n",
    "\n",
    "- a copy of the data is in Google Storage (buckets)\n",
    "- `gcloud ml-engine` output is saved to `OUTDIR`in Google Storage \n",
    "  - checkpoints (logs)\n",
    "  - model graph and weights\n",
    "- data is copied to Google Storage\n",
    "  \n",
    "> NOTE: No with-spaces behind line break symbol **\\**\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "!gsutil -m rm -rf gs://$BUCKET/$PKG_NAME/* "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "code_folding": [
     0
    ],
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "# 10 epochs in global steps:\n",
    "\n",
    "steps = 10000\n",
    "batch_size = 128\n",
    "n_train = 60000\n",
    "print(\"Number of epochs using {} steps: {:.1f}\".format(steps, steps * batch_size / n_train))\n",
    "steps = int(60000 / 128 * 10) + 1\n",
    "print(\"For ten epochs specify {} steps\".format(steps))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "OUTDIR = '/'.join(['gs:/', BUCKET, PKG_NAME, 'trained'])\n",
    "os.environ['OUTDIR'] = OUTDIR "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "!gsutil -m cp ${PWD}/data/mnist/raw/mnist.npz gs://${BUCKET}/$PKG_NAME/data/mnist.npz"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## Start Job"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "OUTDIR=gs://${BUCKET}/$PKG_NAME/trained\n",
    "JOBNAME=mnist_$(date -u +%y%m%d_%H%M%S)\n",
    "echo $OUTDIR $REGION $JOBNAME\n",
    "gsutil -m rm -rf $OUTDIR\n",
    "gcloud ml-engine jobs submit training $JOBNAME \\\n",
    "   --region=$REGION \\\n",
    "   --module-name=$PKG_NAME.task \\\n",
    "   --package-path=${PWD}/src/$PKG_NAME \\\n",
    "   --staging-bucket=gs://$BUCKET \\\n",
    "   --scale-tier=BASIC \\\n",
    "   --python-version 3.5 \\\n",
    "   --runtime-version=$TFVERSION \\\n",
    "   -- \\\n",
    "   --data_path=\"gs://${BUCKET}/$PKG_NAME/data/\" \\\n",
    "   --output_dir=$OUTDIR \\\n",
    "   --train_steps=5000 \\\n",
    "   --job_dir=$OUTDIR/jobs "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### Fetch logs from ml-engine job\n",
    "\n",
    "- replace *mnist_190226_135612* with your `JOBNAME`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "!gcloud ml-engine jobs describe    mnist_190226_135612"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "!gcloud ml-engine jobs stream-logs mnist_190226_135612"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "notes"
    }
   },
   "source": [
    "Don't be concerned if the notebook appears stalled (with a blue progress bar) or returns with an error about being unable to refresh auth tokens. This is a long-lived Cloud job and work is going on in the cloud. \n",
    "\n",
    "**Use the Cloud Console link to monitor the job and do NOT proceed until the job is done.**"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "## Check Results in TensorBoard\n",
    "\n",
    "- metrics and variables are inspected from the logs, called checkpoints (`ckpt`)\n",
    "- Dashboard on localhost: `TensorBoard`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "In Datalab Tensorboard is available using a special package. On your local machine, you can execute tensorflow using the command line.\n",
    "\n",
    "DATALAB:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "from google.datalab.ml import TensorBoard\n",
    "TensorBoard().start(('{}/'+os.environ['PKG_NAME']).format(os.environ['PWD']))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "for pid in TensorBoard.list()['pid']:\n",
    "  TensorBoard().stop(pid)\n",
    "  print('Stopped TensorBoard with pid {}'.format(pid))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "If the above step (to stop TensorBoard) appears stalled, just move on to the next step. You don't need to wait for it to return."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Inspect Models trained on your machine:\n",
    "- `tensorboard --logdir src/pkg_mnist_fnn/trained`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "source activate gcp_dl\n",
    "tensorboard --logdir $PWD/src/$PKG_NAME/trained"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "!echo \"tensorboard --logdir $PWD/src/$PKG_NAME/trained\""
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Or trained on GCP, where results are store in Google Cloud Storage"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "#gcloud auth application-default login\n",
    "echo $OUTDIR\n",
    "tensorboard --logdir $OUTDIR"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "# Deploy model - from any previous step\n",
    "\n",
    "- `tf.estimator.LatestExporter`is used to store a model for deployment in the cloud\n",
    "- See also:  `tf.estimator.export`, `tf.saved_model`\n",
    "\n",
    "[Link to Console](https://console.cloud.google.com/)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "#### Check that a model has been saved on your Bucket:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "gsutil ls gs://${BUCKET}/${PKG_NAME}/trained/export/exporter "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### Deploy"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Identifier for deployed model:\n",
    "- `MODEL_NAME`\n",
    "- `MODEL_VERSION`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "MODEL_NAME=\"MNIST_MLENGINE\"\n",
    "MODEL_VERSION=\"v2\" \n",
    "MODEL_LOCATION=$(gsutil ls gs://${BUCKET}/$PKG_NAME/trained/export/exporter | tail -1)\n",
    "echo \"Run these commands one-by-one (the very first time, you'll create a model and then create a version)\"\n",
    "#gcloud ml-engine versions delete ${MODEL_VERSION} --model ${MODEL_NAME}\n",
    "#gcloud ml-engine models delete ${MODEL_NAME}\n",
    "gcloud ml-engine models   create ${MODEL_NAME} --regions $REGION\n",
    "gcloud ml-engine versions create ${MODEL_VERSION} --model ${MODEL_NAME} --origin ${MODEL_LOCATION} --runtime-version $TFVERSION"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "# Predictions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "1. Using the Model saved by Python Module\n",
    "2. Using Model saved by `ml-engine local`\n",
    "3. Using Model trained online"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "cell_style": "split",
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "Tools get predictions:\n",
    "- Command Line Interfaces\n",
    "    - `gcloud ml-engine local predict`\n",
    "    - `gcloud ml-engine predict`\n",
    "- Python Client"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "### Let's look again at our four examples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [
    {
     "data": {
      "image/png": "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T39azDbYYIO2xx988MHiOZ2+55s/f34x62TTTTctZm9961uL2eGHH17MOm2Lsvvuuxez5cuXtz3+xS9+sXjO97///WJ26623FrNObG8CAADAwFloAgAAUJWFJgAAAFVZaAIAAFCVhSYAAABVWWgCAABQle1NGmznnXcuZrfddlvVa/W6pciSJUuKWa8zdro9fadZjj766GJ2zjnn9DRLbW7TPn5MmTKlmN15553FbLPNNitmV111VdvjTdrCpJNO2yu85z3vKWYLFy4sZh/84AfbHr/mmmu6H6wC3WyWs88+u5gdc8wxA5vjsssuK2Yf//jHi9nvfve7foyzVtLNieGQQw4pZt/61rdG/Xhbb711MVu8ePGoH28YJk2aVMxK26FFlLdM2WGHHYrndNoupdP3z1dccUUxs70JAAAAA2ehCQAAQFUWmgAAAFRloQkAAEBVFpoAAABUZaEJAABAVeX76raklC6KiP0iYlnO+TWtYy+OiMsiYpuIWBAR78g5/6F/Y05cb37zm4vZ5Zdf3tNjXnrppW2P33XXXcVzli1bVsy+973vFbNnn322mD355JPF7KijjipmnbZ6eOqpp4rZtddeW8wmIt0cu05bmNx4443FbOrUqcXsy1/+cjE77rjjuhtsiI4//vhi9t73vreYPfTQQ8XskksuKWY//vGPu5prPNHNseu0TdAg7b///sXsq1/9ajH705/+VMyefvrpMc1E73RzeA477LCezrv11lvbHn/88cfHMk4jPPfcc8XsN7/5TTE75ZRT+jFOX3TziuasiNjnecc+FRFzc87bRcTc1p+BwZoVuglNNCt0E5poVugmDMyIC82c840R8fx/NjggIi5ufXxxRIyP3cZhAtFNaCbdhGbSTRisXn9Gc0rO+ZGIiNbvm9YbCRgD3YRm0k1oJt2EPhnxZzTHKqU0MyJm9vs6wOjoJjSTbkIz6SaMTq+vaC5NKU2NiGj9XryTTM75/JzzLjnnXXq8FtA93YRm0k1oJt2EPul1oXllRLy79fG7I+K7dcYBxkg3oZl0E5pJN6FPUs658yek9M2I2DMi/jUilkbESRHxnYj4VkRsFRGLIuLfcs4j3mc4pdT5YhPUK1/5ymL2k5/8pJhtumn5xwQWLlxYzHbccce2x5cvX148px/23nvvYvbtb3+7mP3zP/9zMTvxxBOL2RlnnNHdYEOUc061Hks3u/ORj3ykmB155JHFbKeddipmnW6rvsceexSzX/3qV8VskPbcc89idtFFFxWzbbbZppj94Ac/KGbTp0/vZqyh0s1mKW3TFRHx7//+7wOcpCyl8l+Zhx9+uJgdfvjhxazTtkorV67sbrAJRjfHj0022aSYddoC69FHHy1m2223Xdvjf/nLX7ofjL7oppsj/oxmznlGIdpr1BMB1egmNJNuQjPpJgxWr2+dBQAAgLYsNAEAAKjKQhMAAICqLDQBAACoykITAACAqka86yzd6bQVwpe//OVittlmmxWzJ554oph12p5gkNuYTJs2rZhdeeWVxWyDDTYoZk8++WQxmzNnTneDsVbZeuuti9npp59ezDbaaKNi9thjjxWz/fffv5g1ZQuTTs4666xi1um5nDdvXjG7+OKLxzQTrK7TNjul7Q4iInbeeed+jDNqL33pS4vZ3Llzi9kRRxxRzGbPnj2WkaDv9t1332K2/vrrF7MVK1YUM9uYjG9e0QQAAKAqC00AAACqstAEAACgKgtNAAAAqrLQBAAAoCoLTQAAAKqyvckodLo185lnnlnMXv/61xezhx56qJgde+yxxWzRokXFrLZ11in/e8RBBx1UzDo9X08//XQxe+1rX1vMBvl10yyTJ08uZmeccUYx23DDDXu63owZM4rZz3/+854esymWLl3a03nHHHNMMbv55pt7HQfWcMMNNxSzTv3rtGXYhz70oWK27bbbtj3eaSujfthvv/2Kme1NaLpOW4axdvKKJgAAAFVZaAIAAFCVhSYAAABVWWgCAABQlYUmAAAAVaWc8+AultLgLtYHX/rSl4pZp7vZdXLaaacVs5NPPrmnx6zt0EMPLWZz5szp6TFPOeWUYnbqqaf29JjjQc45DXuGdprSzR133LGYnXfeecVs1113rT7Lgw8+WMw63bV17ty5xWzhwoWjnuMb3/jGqM+J6Hwn3sMOO6yYzZs3r5jNnDmzmPV6J9um0E3amTZtWjHr9P+qTneP7dVRRx1VzDr993G8083x4yUveUkx+93vflfMHn/88WK20047tT2+ZMmS7gejL7rpplc0AQAAqMpCEwAAgKosNAEAAKjKQhMAAICqLDQBAACoykITAACAqkbc3iSldFFE7BcRy3LOr2kdOzki3h8Rv2992gk556tHvNg4vxX0FVdcUcze9ra3FbMbbrihmB1wwAHF7JlnnulusAqmTp1azDrNv/322xez22+/vZi94Q1vKGZ//etfi9l4V/M27ROxm1dddVUxmz59ejF77LHHitm9997b0yyd/o4OcluoZcuWFbPrr7++mHXawmTBggXFrNN/y+bPn1/MxjvdZLQmT55czGbNmlXMDj744J6ud8sttxSz3XffvafHHA90c/z4p3/6p2L2s5/9rJh12trsne98Z9vj3/zmN7sfjL6otb3JrIjYp83xL+Scp7V+jVhIoLpZoZvQRLNCN6GJZoVuwsCMuNDMOd8YEeWdVIGh0E1oJt2EZtJNGKyx/Izmh1NKd6WULkopvajaRMBY6SY0k25CM+km9EGvC82vRcTLI2JaRDwSEZ8vfWJKaWZK6faUUvkH9oBadBOaSTehmXQT+qSnhWbOeWnOeUXOeWVEXBARu3b43PNzzrvknHfpdUigO7oJzaSb0Ey6Cf3T00IzpbT6LUoPioiJeytCGEd0E5pJN6GZdBP6Z9JIn5BS+mZE7BkR/5pSWhwRJ0XEnimlaRGRI2JBRPxnH2dsjHPPPbeYPfjgg8Xs1FNPLWaD3MKkk8suu6yYddrCZOHChcVsxowZxWwib2EyKBOxm3fffXcxu+OOO4rZBRdcUMwefvjhnmZ51ate1dN5e++9dzHbYost2h7fb7/9iue8/OUvL2b/8R//Ucw6bcHyhS98oZhN5C1MBmUidpM1PfXUU8Ws0/cLvW5vwtjpZn89/fTTxeyLX/xiMbvooouK2Ve+8pW2x3/7298Wz7n11luL2cqVK4sZ9Y240Mw5t1stXNiHWYBR0E1oJt2EZtJNGKyx3HUWAAAA1mChCQAAQFUWmgAAAFRloQkAAEBVFpoAAABUlTrdAr/6xVIa3MXWYhtuuGHb4xdffHHxnLe//e3F7Nlnny1mH/jAB4rZN77xjWK2tso5p2HP0I5uNteCBQuK2ZZbblnMPv3pTxez008/vZh16vtEppvUtNdeexWz6667rqfHvOWWW4rZ7rvv3tNjjge6OTGUtveKiJg9e3Yx22OPPUZ9rWuuuaaYnXXWWcXsRz/60aivtTbrppte0QQAAKAqC00AAACqstAEAACgKgtNAAAAqrLQBAAAoCoLTQAAAKqaNOwBqO/CCy9se/zggw8untNpS4Ojjz66mNnCBLq36aabtj0+d+7c4jlbbbVVMXv00UeLmS1MaLpOf7ePPPLInh7z6quvLma33nprT49ZssEGGxSzQw89tOq1YLxbvHhxMev0/enxxx/f9vhHPvKR4jn77LNPMbvqqquKme1N6vOKJgAAAFVZaAIAAFCVhSYAAABVWWgCAABQlYUmAAAAVVloAgAAUJXtTcap3XbbrZgdeOCBo368M844o5idd955o348YE2HH3542+M77LBD8ZylS5eO+vEibGFC8/3whz8sZttuu21Pj3niiScWs2uuuaaYnXTSSW2Pv+pVryqeU9quKKL37VlgbfSHP/yhmB177LFtj7///e8vnvOCF7xgzDNRh1c0AQAAqMpCEwAAgKosNAEAAKjKQhMAAICqLDQBAACoykITAACAqkbc3iSltGVEXBIRm0XEyog4P+f8XymlF0fEZRGxTUQsiIh35JzL9ydm1CZPnlzMLrjggmJWuq3zDTfcUDznzDPP7H4wGkE3m+mzn/1sMfvkJz856sd74xvfWMzuv//+UT8e/aebfzdt2rRitsUWW1S/3jrrlP/9fN999y1me+65Z9vjG264YfGclFIxyzkXs046nfe1r32tp8fk73SzmdZdd91idvLJJ7c9vvHGGxfPeeyxx4rZvHnzup6LsevmFc3nIuITOedXR8T/iYgPpZR2iIhPRcTcnPN2ETG39WdgcHQTmkk3oZl0EwZoxIVmzvmRnPOdrY+fjIh7ImLziDggIi5ufdrFEXFgv4YE1qSb0Ey6Cc2kmzBYI751dnUppW0i4nURcUtETMk5PxKxqrgppU0L58yMiJljGxPoRDehmXQTmkk3of+6XmimlDaKiMsj4qM55yc6/WzC6nLO50fE+a3H6O2HFoAi3YRm0k1oJt2EwejqrrMppfViVSHn5Jz/p3V4aUppaiufGhHL+jMiUKKb0Ey6Cc2kmzA4Iy4006p/5rkwIu7JOZ+9WnRlRLy79fG7I+K79ccDSnQTmkk3oZl0EwYrjXQL7pTSGyLipoj4Zay6FXRExAmx6j3t34qIrSJiUUT8W8758REey9sMnmfKlCnF7JJLLilme++9dzH74x//2Pb4brvtVjzngQceKGbUk3Pu7v05XdDN/lpvvfWK2dlnn13M3vWudxWzJ554ou3xGTNmFM+5+eabixn16GZ/vO997ytm55133gAnqa/TViorV64sZp1ceumlxezwww/v6THHO92c+E477bRidsIJJ7Q9vnz58uI5nb7fvffee7sfjI666eaIP6OZc745IkoPtNdohwLq0E1oJt2EZtJNGKyufkYTAAAAumWhCQAAQFUWmgAAAFRloQkAAEBVFpoAAABUNeJdZ+mvY489tpi96U1vKmaPPfZYMXvFK17R9vif/vSn7geDtdzWW29dzA477LBiVtrCJCLi6KOPbnvcFiZMVFdffXUx+/73v1/Mpk+f3o9xqhppe7iSRYsWFbNTTjml13FgVF7zmtcUs5122qmYzZkzp5itu+66xezUU08tZscdd1wxe+qpp9oeP/jgg4vn2MKkObyiCQAAQFUWmgAAAFRloQkAAEBVFpoAAABUZaEJAABAVRaaAAAAVJV6vT13TxdLaXAXa5BOWyHMnj27mK1YsaKYdboF+umnn97dYAxczjkNe4Z21tZudrLeeusVs/e85z3F7Pe//30xu+KKK8Y0E/2jm4PXaSuELbfcspgdeuihxezEE08sZvfff38xmzZtWjEruemmm4rZvHnzitm5555bzO67775RzzHR6WZ/fOpTnypmJ510UjF79atfXcyOPPLIYtapm3/+85+L2SGHHNL2+HXXXVc8h8Hoppte0QQAAKAqC00AAACqstAEAACgKgtNAAAAqrLQBAAAoCp3na3kiCOOKGaf+9znitkmm2xSzD7zmc8Us+OPP76ruWgWd8+DZtJNaCbd7I8dd9yxmP385z8vZuusU36NatKkScVs+fLlxax0Z9mIiLlz5xYzhstdZwEAABg4C00AAACqstAEAACgKgtNAAAAqrLQBAAAoCoLTQAAAKoacXuTlNKWEXFJRGwWESsj4vyc83+llE6OiPdHxO9bn3pCzvnqER5rXN8KeuONNy5m9913XzGbMmVKMbv++uuL2fTp04vZihUrihnNVfM27boJ9egmNJNuDt5pp51WzE444YRidskllxSzM888s5h1+h6a5uqmm+UNb/7uuYj4RM75zpTSxhFxR0rpb6ujL+SczxrLkEDPdBOaSTehmXQTBmjEhWbO+ZGIeKT18ZMppXsiYvN+DwZ0ppvQTLoJzaSbMFij+hnNlNI2EfG6iLildejDKaW7UkoXpZReVHk2oEu6Cc2km9BMugn91/VCM6W0UURcHhEfzTk/ERFfi4iXR8S0WPWvQ58vnDczpXR7Sun2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\n",
      "text/plain": [
       "<Figure size 1440x288 with 4 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "from src.utils.mnist_utils import plot_mnist_testdata\n",
    "plot_mnist_testdata()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## ML-Engine: `ml-engine local predict`\n",
    "- Using Model saved\n",
    "  - Python module\n",
    "  - `ml-engine local`"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "### `ML-Engine local` using Python 3 ...\n",
    "you still have to remove manually some compiled python files"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "!ls /usr/lib/google-cloud-sdk/lib/googlecloudsdk/command_lib/ml_engine/"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "In order to work with `Python 3`, delete the `*.pyc` files, see [post](https://stackoverflow.com/questions/48824381/gcloud-ml-engine-local-predict-runtimeerror-bad-magic-number-in-pyc-file)\n",
    "\n",
    "Default Datalab\n",
    "```\n",
    "rm /tools/google-cloud-sdk/lib/googlecloudsdk/command_lib/ml_engine/*.pyc\n",
    "```\n",
    "Default UNIX:\n",
    "```\n",
    "sudo rm /usr/lib/google-cloud-sdk/lib/googlecloudsdk/command_lib/ml_engine/*.pyc\n",
    "```\n",
    "\n",
    "> Process running Datalab or Jupyter Notebook needs admin rights. This is not always given for locally run notebooks"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "# #remove any pyc files: Using Python3 you have to recompile\n",
    "# #Note: you need admin rights\n",
    "rm /tools/google-cloud-sdk/lib/googlecloudsdk/command_lib/ml_engine/*.pyc\n",
    "# sudo rm /usr/lib/google-cloud-sdk/lib/googlecloudsdk/command_lib/ml_engine/*.pyc "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "source activate gcp_dl\n",
    "model_dir=$(ls $PWD/src/$PKG_NAME/trained/export/exporter/ | tail -1)\n",
    "echo \"Selected Model:  $model_dir\" \n",
    "gcloud ml-engine local predict \\\n",
    "    --model-dir=${PWD}/src/${PKG_NAME}/trained/export/exporter/${model_dir} \\\n",
    "    --json-instances=./data/test.json \\\n",
    "    --verbosity debug > data/test_predictions\n",
    "cat data/test_predictions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "gcloud ml-engine local predict --help"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## Online Prediction - Command Line\n",
    "\n",
    "- same output format as before"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "%%bash\n",
    "gcloud ml-engine predict --model=MNIST_MLENGINE --version=v1 --json-instances=data/test.json"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "> Check Console"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "plot_mnist_testdata()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## Online Prediction - Python Client"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "- Get predictions using the [Python-Client-Library, see Tutorial](https://cloud.google.com/ml-engine/docs/tensorflow/python-client-library). \n",
    "\n",
    "- [API-Reference](https://cloud.google.com/ml-engine/reference/rest/)\n",
    "\n",
    "-  service account authentification:  [link](https://cloud.google.com/iam/docs/creating-managing-service-accounts)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "# %bash\n",
    "# export GOOGLE_APPLICATION_CREDENTIALS=$PWD/ML-productive-pipeline-53122-64d3c31786e7.json\n",
    "# echo $GOOGLE_APPLICATION_CREDENTIALS"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "# os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = '/content/datalab/proj_DL_models_and_pipelines_with_GCP/notebook/../ML-productive-pipeline-53122-64d3c31786e7.json'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "from oauth2client.client import GoogleCredentials\n",
    "from googleapiclient import    \n",
    "from googleapiclient import errors\n",
    "import json"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": [
    "%pdoc discovery.build"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "```\n",
    "Signature: discovery.build(serviceName, version, http=None, discoveryServiceUrl='https://www.googleapis.com/discovery/v1/apis/{api}/{apiVersion}/rest', developerKey=None, model=None, requestBuilder=<class 'googleapiclient.http.HttpRequest'>, credentials=None, cache_discovery=True, cache=None)\n",
    "Docstring:\n",
    "Construct a Resource for interacting with an API.\n",
    "\n",
    "Construct a Resource object for interacting with an API. The serviceName and\n",
    "version are the names from the Discovery service.\n",
    "\n",
    "Args:\n",
    "serviceName: string, name of the service.\n",
    "version: string, the version of the service.\n",
    "http: httplib2.Http, An instance of httplib2.Http or something that acts\n",
    "like it that HTTP requests will be made through.\n",
    "discoveryServiceUrl: string, a URI Template that points to the location of\n",
    "the discovery service. It should have two parameters {api} and\n",
    "{apiVersion} that when filled in produce an absolute URI to the discovery\n",
    "document for that service.\n",
    "developerKey: string, key obtained from\n",
    "https://code.google.com/apis/console.\n",
    "model: googleapiclient.Model, converts to and from the wire format.\n",
    "requestBuilder: googleapiclient.http.HttpRequest, encapsulator for an HTTP\n",
    "request.\n",
    "credentials: oauth2client.Credentials or\n",
    "google.auth.credentials.Credentials, credentials to be used for\n",
    "authentication.\n",
    "cache_discovery: Boolean, whether or not to cache the discovery doc.\n",
    "cache: googleapiclient.discovery_cache.base.CacheBase, an optional\n",
    "cache object for the discovery documents.\n",
    "\n",
    "Returns:\n",
    "A Resource object with methods for interacting with the service.\n",
    "File: /usr/local/envs/py3env/lib/python3.5/site-packages/googleapiclient/discovery.py\n",
    "Type: function\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "api = discovery.build(serviceName='ml', version='v1',\n",
    "                      http=None, \n",
    "                      discoveryServiceUrl='https://www.googleapis.com/discovery/v1/apis/{api}/{apiVersion}/rest', \n",
    "                      developerKey=None, \n",
    "                      model=None,  \n",
    "                      #requestBuilder= googleapiclient.http.HttpRequest, \n",
    "                      credentials=None, \n",
    "                      cache_discovery=True, \n",
    "                      cache=None)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "outputs": [],
   "source": [
    "MODEL_NAME = 'MNIST_MLENGINE' \n",
    "VERSION = 'v1'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "code_folding": [
     0
    ],
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "# Load data\n",
    "from src.pkg_mnist_fnn.utils import load_data\n",
    "from src.pkg_mnist_fnn.model import parse_images\n",
    "(_,_), (x_test, y_test) = load_data(rel_path='data')\n",
    "N=4\n",
    "test_indices = np.random.randint(low=0, high=len(y_test), size=N)\n",
    "x_test, y_test = x_test[test_indices], y_test[test_indices]\n",
    "x_test = parse_images(x_test).tolist()\n",
    "\n",
    "eol = \"\\r\\n\"\n",
    "n_lines = len(y_test)\n",
    "instances = []\n",
    "with open(\"data/test.json\", \"r\") as f:\n",
    "    for image, label in zip(x_test, y_test):\n",
    "        instances.append({\"x\": image}) #, \"y\": int(label)}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "project_id = 'projects/{}/models/{}/versions/{}'.format(PROJECT, MODEL_NAME, VERSION)\n",
    "request_data = {\"instances\":\n",
    "    instances\n",
    "}\n",
    "request = api.projects().predict(body=request_data, name=project_id).execute()\n",
    "print(request)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "for i, pred in enumerate(request['predictions']):\n",
    "    print(\"Predicted class: {}, True Class:\\t{}\".format(pred['classes'][0], y_test[i]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "# Recap"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "![gcp_training_options-gcp_services.png](Images/gcp_training_options-gcp_services.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "## Outlook\n",
    "- Add different models types\n",
    "    - different layers of abstraction in tensorflow\n",
    "    - sklearn\n",
    "- Show how to use `ml-engine` in SQL in BigQuery"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "# Appendix"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "#### Notes on Jupyter Slides\n",
    "- Activate: View -> Cell Toolbar -> Slideshow\n",
    "- [nbextensions](https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/install.html)\n",
    "   - [split cells vertically](https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/nbextensions/splitcell/readme.html)\n",
    "   - install into base conda environment\n",
    "- [RISE](https://damianavila.github.io/RISE/installation.html) for interactive presentations\n",
    "  - using conda: `conda install -c damianavila82 rise`\n",
    "  - activte scrolling in Notebook-Metadata, see [link](https://damianavila.github.io/RISE/customize.html#config-right-scroll) \n",
    "  - adapt width and height of your slides to your machine and needs. [link](https://damianavila.github.io/RISE/customize.html#change-the-width-and-height-of-slides)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "celltoolbar": "Slideshow",
  "kernelspec": {
   "display_name": "gcp_dl",
   "language": "python",
   "name": "gcp_dl"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  },
  "livereveal": {
   "scroll": true
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
